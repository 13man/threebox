import router from '@ohos.router';
import { common } from '@kit.AbilityKit';
import promptAction from '@ohos.promptAction';
import { TextReader, ReadStateCode } from '@kit.SpeechKit';

// è¯—è¯æ•°æ®æ¥å£
interface LivePoem {
  id: number;
  title: string;
  author: string;
  content: string;
  type: 'tang' | 'song' | 'yuan'; // ç±»å‹ï¼šå”è¯—/å®‹è¯/å…ƒæ›²
  scene: string; // åœºæ™¯æè¿°ï¼šæ˜¥æ±ŸèŠ±æœˆå¤œã€é›ªå±±å¯’æ¢…ç­‰
}

// ç²’å­æ¥å£
interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  size: number;
  alpha: number;
  color: string;
  life: number;
  type?: string;  // ç²’å­ç±»å‹: 'petal'èŠ±ç“£, 'tide'æ½®æ°´, 'light'æµå…‰
}

// èŠ±ç“£ç²’å­æ¥å£
interface Petal {
  x: number;
  y: number;
  vx: number;
  vy: number;
  rotation: number;  // æ—‹è½¬è§’åº¦
  rotationSpeed: number;  // æ—‹è½¬é€Ÿåº¦
  size: number;
  alpha: number;
  color: string;
  isFalling: boolean;  // æ˜¯å¦æ­£åœ¨ä¸‹è½
}

// å­”æ˜ç¯æ¥å£ (æ°´è°ƒæ­Œå¤´)
interface Lantern {
  x: number;
  y: number;
  vy: number;  // ä¸Šå‡é€Ÿåº¦
  size: number;
  alpha: number;
  color: string;
  isExploding: boolean;  // æ˜¯å¦æ­£åœ¨çˆ†ç‚¸
  explodeProgress: number;  // çˆ†ç‚¸è¿›åº¦ (0-1)
}

// ä½ç½®åæ ‡æ¥å£ (ç”¨äºå­”æ˜ç¯æ‹¼å­—)
interface Position {
  x: number;
  y: number;
}

// è¯—å¥æ ·å¼æ¥å£
interface LineStyle {
  fontSize: number;
  fontColor: string | Resource;
  fontWeight: FontWeight;
  opacity: number;
}

@Entry
@Component
export struct PoetryLivePage {
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  
  @State private currentPoemIndex: number = 0;
  @State private isPlaying: boolean = false;
  @Prop @Watch('onVisibilityChange') isVisible: boolean = true;  // ç”¨äºç›‘æ§tabå¯è§æ€§
 @State private moonX: number = 0.7; // æœˆäº®Xä½ç½® (0-1)
  @State private moonY: number = 0.3; // æœˆäº®Yä½ç½® (0-1)
  @State private waveOffset: number = 0;
  @State private particleOpacity: number = 1.0;
  @State private moonScale: number = 1.0; // æœˆäº®ç¼©æ”¾ (é™å¤œæ€äº¤äº’)
  @State private libaiAlpha: number = 0; // æç™½å‰ªå½±é€æ˜åº¦ (é™å¤œæ€äº¤äº’)
  @State private moonBrightness: number = 0.5; // æœˆå…‰äº®åº¦ (å‘¼å¸æ•ˆæœ)
  @State private highlightFrost: boolean = false; // æ˜¯å¦é«˜äº®"ç–‘æ˜¯åœ°ä¸Šéœœ"
  
  // æ˜¥æ±ŸèŠ±æœˆå¤œçŠ¶æ€
  @State private moonAngle: number = 0; // æœˆäº®æ—‹è½¬è§’åº¦ (åŒæŒ‡æ—‹è½¬)
  @State private tideHeight: number = 0; // æ½®æ°´é«˜åº¦ (0-1)
  @State private moonPhase: number = 0; // æœˆç›¸ (0=æ–°æœˆ, 0.5=æ»¡æœˆ, 1=æœˆé£Ÿ)
  @State private lightPathAlpha: number = 0; // å…‰è·¯é€æ˜åº¦
  @State private boatAlpha: number = 0; // æ‰èˆŸé€æ˜åº¦
  @State private mapVisible: boolean = false; // æ˜¯å¦æ˜¾ç¤ºåœ°å›¾
  
  // æ°´è°ƒæ­Œå¤´çŠ¶æ€ (ä¸­ç§‹å¤œ)
  @State private moonRiseProgress: number = 0; // æœˆäº®å‡èµ·è¿›åº¦ (0-1)
  @State private palaceAlpha: number = 0; // æœˆå®«é€æ˜åº¦
  @State private changEAlpha: number = 0; // å«¦å¨¥é€æ˜åº¦
  @State private suShiAlpha: number = 0; // è‹è½¼é€æ˜åº¦
  @State private cupAlpha: number = 0; // é…’æ¯é€æ˜åº¦
  @State private shadowCount: number = 1; // äººå½±æ•°é‡ (1æˆ–3)
  @State private shadowRotation: number = 0; // äººå½±æ—‹è½¬è§’åº¦
  @State private timeCountdown: number = -1; // æ—¶é—´éš§é“å€’è®¡æ—¶ (-1è¡¨ç¤ºä¸æ˜¾ç¤º)
  @State private lanternBurst: boolean = false; // å­”æ˜ç¯çˆ†ç‚¸
  @State private moonPhaseValue: number = 1.0; // æœˆç›¸å€¼ (0=æ–°æœˆ, 1=æ»¡æœˆ)
  
  // å¤©å‡€æ²™Â·ç§‹æ€çŠ¶æ€ (é»„æ˜å¤é“)
  @State private scrollOffset: number = 0; // å·è½´æ»šåŠ¨åç§»
  @State private crowsFlying: boolean = false; // ä¹Œé¸¦æ˜¯å¦é£èµ·
  @State private crowEyeOpen: boolean = false; // ä¹Œé¸¦ççœ¼
  @State private waterRipple: number = 0; // æ°´é¢æ³¢çº¹ç¨‹åº¦
  @State private horseStop: boolean = false; // ç˜¦é©¬åœä¸‹
  @State private tianyaText: boolean = false; // å¤©æ¶¯æ–‡å­—æ˜¾ç¤º
  @State private sunsetProgress: number = 0; // å¤•é˜³ä¸‹æ²‰è¿›åº¦ (0-1)
  @State private vignetteAlpha: number = 0; // æš—è§’é€æ˜åº¦
  @State private duanchangText: boolean = false; // æ–­è‚ äººåœ¨å¤©æ¶¯æ®‹å½±
  
  private particles: Particle[] = [];
  private petals: Petal[] = [];  // èŠ±ç“£ç²’å­æ•°ç»„
  private lanterns: Lantern[] = [];  // å­”æ˜ç¯æ•°ç»„ (æ°´è°ƒæ­Œå¤´)
  private animationId: number = -1;
  private canvasWidth: number = 0;
  private canvasHeight: number = 0;
  private isInit: boolean = false;
  private breathePhase: number = 0; // å‘¼å¸åŠ¨ç”»ç›¸ä½
  private gooseX: number = -100; // å­¤é›Xä½ç½®
  private gooseY: number = 0; // å­¤é›Yä½ç½®
  private showGoose: boolean = false; // æ˜¯å¦æ˜¾ç¤ºå­¤é›
  private touchStartY: number = 0; // è§¦æ‘¸èµ·å§‹ä½ç½®Y
  private touchStartX: number = 0; // è§¦æ‘¸èµ·å§‹ä½ç½®X
  private tidePhase: number = 0;  // æ½®æ±ç›¸ä½ (0-2Ï€)
  private longPressTimer: number = -1;  // é•¿æŒ‰è®¡æ—¶å™¨
  private timeAcceleration: number = 1.0;  // æ—¶é—´åŠ é€Ÿå€ç‡
  private seaWavePhase: number = 0;  // æµ·é¢æ³¢çº¹ç›¸ä½ (æ°´è°ƒæ­Œå¤´)
  
  // å®šæ—¶å™¨å’Œé—´éš”å™¨ç®¡ç†
  private effectTimers: number[] = [];  // å­˜å‚¨æ‰€æœ‰setTimeoutè¿”å›å€¼
  private effectIntervals: number[] = [];  // å­˜å‚¨æ‰€æœ‰setIntervalè¿”å›å€¼
  
  // è¯—è¯Liveæ•°æ®
  private livePoems: LivePoem[] = [
    {
      id: 1,
      title: 'å¤©å‡€æ²™Â·ç§‹æ€',
      author: 'é©¬è‡´è¿œ',
      content: 'æ¯è—¤è€æ ‘æ˜é¸¦ï¼Œ\nå°æ¡¥æµæ°´äººå®¶ï¼Œ\nå¤é“è¥¿é£ç˜¦é©¬ã€‚\nå¤•é˜³è¥¿ä¸‹ï¼Œ\næ–­è‚ äººåœ¨å¤©æ¶¯ã€‚',
      type: 'yuan',
      scene: 'autumn_dusk'
    },
    {
      id: 2,
      title: 'æ˜¥æ±ŸèŠ±æœˆå¤œ',
      author: 'å¼ è‹¥è™š',
      content: 'æ˜¥æ±Ÿæ½®æ°´è¿æµ·å¹³ï¼Œæµ·ä¸Šæ˜æœˆå…±æ½®ç”Ÿã€‚\næ»Ÿæ»Ÿéšæ³¢åƒä¸‡é‡Œï¼Œä½•å¤„æ˜¥æ±Ÿæ— æœˆæ˜ã€‚\næ±Ÿæµå®›è½¬ç»•èŠ³ç”¸ï¼Œæœˆç…§èŠ±æ—çš†ä¼¼éœ°ã€‚\nç©ºé‡Œæµéœœä¸è§‰é£ï¼Œæ±€ä¸Šç™½æ²™çœ‹ä¸è§ã€‚',
      type: 'tang',
      scene: 'river_moon'
    },
    {
      id: 3,
      title: 'é™å¤œæ€',
      author: 'æç™½',
      content: 'åºŠå‰æ˜æœˆå…‰ï¼Œç–‘æ˜¯åœ°ä¸Šéœœã€‚\nä¸¾å¤´æœ›æ˜æœˆï¼Œä½å¤´æ€æ•…ä¹¡ã€‚',
      type: 'tang',
      scene: 'night_moon'
    },
    {
      id: 4,
      title: 'æ±Ÿé›ª',
      author: 'æŸ³å®—å…ƒ',
      content: 'åƒå±±é¸Ÿé£ç»ï¼Œä¸‡å¾„äººè¸ªç­ã€‚\nå­¤èˆŸè“‘ç¬ ç¿ï¼Œç‹¬é’“å¯’æ±Ÿé›ªã€‚',
      type: 'tang',
      scene: 'snow_river'
    },
    {
      id: 5,
      title: 'æ°´è°ƒæ­Œå¤´Â·æ˜æœˆå‡ æ—¶æœ‰',
      author: 'è‹è½¼',
      content: 'æ˜æœˆå‡ æ—¶æœ‰ï¼ŸæŠŠé…’é—®é’å¤©ã€‚\nä¸çŸ¥å¤©ä¸Šå®«é˜™ï¼Œä»Šå¤•æ˜¯ä½•å¹´ã€‚\næˆ‘æ¬²ä¹˜é£å½’å»ï¼Œåˆæç¼æ¥¼ç‰å®‡ï¼Œé«˜å¤„ä¸èƒœå¯’ã€‚\nèµ·èˆå¼„æ¸…å½±ï¼Œä½•ä¼¼åœ¨äººé—´ã€‚\n\nè½¬æœ±é˜ï¼Œä½ç»®æˆ·ï¼Œç…§æ— çœ ã€‚\nä¸åº”æœ‰æ¨ï¼Œä½•äº‹é•¿å‘åˆ«æ—¶åœ†ï¼Ÿ\näººæœ‰æ‚²æ¬¢ç¦»åˆï¼Œæœˆæœ‰é˜´æ™´åœ†ç¼ºï¼Œæ­¤äº‹å¤éš¾å…¨ã€‚\nä½†æ„¿äººé•¿ä¹…ï¼Œåƒé‡Œå…±å©µå¨Ÿã€‚',
      type: 'song',
      scene: 'moon_palace'
    }
  ];

  async aboutToAppear(): Promise<void> {
    console.log('ğŸ›¡ï¸ Poetry Live Page: aboutToAppear');
    // è·å–è·¯ç”±å‚æ•°
    const params = router.getParams() as Record<string, Object>;
    if (params && params['poemIndex'] !== undefined) {
      this.currentPoemIndex = params['poemIndex'] as number;
    }
  }

  aboutToDisappear(): void {
    // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
    this.clearAllTimers();
    console.log('ğŸ›¡ï¸ Poetry Live Page: aboutToDisappear');
    // åœæ­¢åŠ¨ç”»
    if (this.animationId !== -1) {
      // HarmonyOSä¸æ”¯æŒcancelAnimationFrame,ä½¿ç”¨æ ‡å¿—ä½æ§åˆ¶
      this.animationId = -1;
    }
    
    // æ¸…ç†é•¿æŒ‰è®¡æ—¶å™¨
    if (this.longPressTimer !== -1) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = -1;
    }
    
    // é‡Šæ”¾TextReader
    this.cleanupTextReader();
    
    // æ¸…ç©ºç²’å­æ•°ç»„
    this.particles = [];
    this.petals = [];
    this.lanterns = [];
    
    console.log('ğŸ›¡ï¸ Poetry Live Page: èµ„æºå·²æ¸…ç†');
  }
  

  
  // Tabå¯è§æ€§å˜åŒ–ç›‘å¬å™¨
  onVisibilityChange(): void {
    if (!this.isVisible) {
      // Tabéšè—æ—¶æš‚åœæ’­æ”¾
      if (this.isPlaying) {
        try {
          TextReader.stop();
          // é‡Šæ”¾TextReaderèµ„æº
          TextReader.release().then(() => {
            console.log('TextReaderèµ„æºé‡Šæ”¾æˆåŠŸ');
          }).catch((error: Error) => {
            console.error('TextReaderèµ„æºé‡Šæ”¾å¤±è´¥:', error);
          });
          this.isPlaying = false;
          this.isInit=false;
          console.log('ğŸš« Poetry Live Tab: éšè—ï¼Œæš‚åœæ’­æ”¾');
        } catch (error) {
          console.error('Poetry æš‚åœTextReaderå¤±è´¥:', error);
        }
      }else {
        console.log('ğŸš« Poetry isVisible true');
      }
    } else {
      // Tabæ˜¾ç¤ºæ—¶é‡æ–°åˆå§‹åŒ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (!this.isInit) {
        this.initTextReader();
        console.log('âœ… Poetry Live Tab: æ˜¾ç¤ºï¼Œé‡æ–°åˆå§‹åŒ–TextReader');
      }else {
        console.log('âœ…Poetry isInit true');
      }
    }
  }
  
  // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨å’Œé—´éš”å™¨
  private clearAllTimers(): void {
    // æ¸…ç†æ‰€æœ‰setTimeout
    this.effectTimers.forEach((timerId: number) => {
      clearTimeout(timerId);
    });
    this.effectTimers = [];
    
    // æ¸…ç†æ‰€æœ‰setInterval
    this.effectIntervals.forEach((intervalId: number) => {
      clearInterval(intervalId);
    });
    this.effectIntervals = [];
  }
  
  // æ¸…ç†TextReaderèµ„æº
  private cleanupTextReader(): void {
    try {
      if (this.isInit) {
        console.error('Poetry cleanupTextReader:');
        TextReader.stop();
        TextReader.off('stateChange');  // å–æ¶ˆäº‹ä»¶ç›‘å¬
        TextReader.release();
        this.isInit = false;
        this.isPlaying = false;
      }
    } catch (error) {
      console.error('Poetry é‡Šæ”¾TextReaderå¤±è´¥:', error);
    }
  }
  
  // å®‰å…¨çš„setTimeoutåŒ…è£…å™¨
  private safeSetTimeout(callback: () => void, delay: number): void {
    const timerId = setTimeout(callback, delay);
    this.effectTimers.push(timerId);
  }
  
  // å®‰å…¨çš„setIntervalåŒ…è£…å™¨
  private safeSetInterval(callback: () => void, delay: number): void {
    const intervalId = setInterval(callback, delay);
    this.effectIntervals.push(intervalId);
  }

  // åˆå§‹åŒ–TextReader
  private async initTextReader(): Promise<void> {
    try {
      const businessBrandInfo: TextReader.BusinessBrandInfo = { 
        panelName: 'è¯—è¯Liveæœ—è¯µ'
      };
      
      const readerParam: TextReader.ReaderParam = {
        isVoiceBrandVisible: true,
        businessBrandInfo: businessBrandInfo,
        keepBackgroundRunning: true
      };

      await TextReader.init(getContext(this), readerParam);
      this.isInit = true;
      
      // ç›‘å¬æœ—è¯»çŠ¶æ€
      TextReader.on('stateChange', (state: TextReader.ReadState) => {
        if (state.state === ReadStateCode.PLAYING) {
          this.isPlaying = true;
        } else if (state.state === ReadStateCode.COMPLETED || 
                   state.state === ReadStateCode.WAITING) {
          this.isPlaying = false;
        }
      });
    } catch (error) {
      console.error('Poetry TextReaderåˆå§‹åŒ–å¤±è´¥:', error);
      this.isInit = false;
    }
  }

  // å¼€å§‹æœ—è¯µ
  private async startRecitation(): Promise<void> {
    if (!this.isInit) {
      promptAction.showToast({ message: 'æœ—è¯µåŠŸèƒ½åˆå§‹åŒ–ä¸­...' });
      return;
    }
    
    // æ¸…ç†ä¹‹å‰çš„æ‰€æœ‰ç‰¹æ•ˆå®šæ—¶å™¨
    this.clearAllTimers();
    
    const poem = this.livePoems[this.currentPoemIndex];
    
    try {
      TextReader.stop();
      
      // æ˜¥æ±ŸèŠ±æœˆå¤œ - å¯åŠ¨ç‰¹æ•ˆåºåˆ—
      if (poem.scene === 'river_moon') {
        this.triggerRiverMoonEffects();
      }
      
      // é™å¤œæ€ - å¯åŠ¨ç‰¹æ•ˆåºåˆ—
      if (poem.scene === 'night_moon') {
        this.triggerNightMoonEffects();
      }
      
      // æ°´è°ƒæ­Œå¤´ - å¯åŠ¨ç‰¹æ•ˆåºåˆ—
      if (poem.scene === 'moon_palace') {
        this.triggerMoonPalaceEffects();
        // åˆå§‹åŒ–å­”æ˜ç¯
        this.initLanterns();
      }
      
      // å¤©å‡€æ²™Â·ç§‹æ€ - å¯åŠ¨ç‰¹æ•ˆåºåˆ—
      if (poem.scene === 'autumn_dusk') {
        this.triggerAutumnDuskEffects();
      }
      
      // åˆ›å»ºæœ—è¯»ä¿¡æ¯ - ä½¿ç”¨æ­£ç¡®çš„ReadInfoæ ¼å¼
      const readInfo: TextReader.ReadInfo = {
        id: `poetry_live_${poem.id}`,
        title: {
          text: poem.title,
          isClickable: false
        },
        bodyInfo: `${poem.title},ä½œè€…:${poem.author}ã€‚${poem.content}`
      };
      
      // å¼€å§‹æœ—è¯»
      TextReader.start([readInfo]).then(() => {
        console.log('å¼€å§‹æœ—è¯µ');
        this.isPlaying = true;
      }).catch((error: Error) => {
        console.error('æœ—è¯µå¤±è´¥:', error);
        promptAction.showToast({ message: 'æœ—è¯µå¤±è´¥' });
      });
    } catch (error) {
      console.error('æœ—è¯µå¤±è´¥:', error);
      promptAction.showToast({ message: 'æœ—è¯µå¤±è´¥' });
    }
  }

  // æ˜¥æ±ŸèŠ±æœˆå¤œç‰¹æ•ˆåºåˆ—
  private triggerRiverMoonEffects(): void {
    // "æ˜¥æ±Ÿæ½®æ°´è¿æµ·å¹³" - æ½®æ°´æ¶Œèµ·
    this.safeSetTimeout(() => {
      this.tideHeight = 0.8;
    }, 2000);
    
    // "æµ·ä¸Šæ˜æœˆå…±æ½®ç”Ÿ" - æœˆäº®ä¸Šå‡
    this.safeSetTimeout(() => {
      this.moonY = 0.2;
    }, 4000);
    
    // "æ»šæº­éšæ³¢åƒä¸‡é‡Œ" - å…‰è·¯å‡ºç°
    this.safeSetTimeout(() => {
      this.lightPathAlpha = 0.8;
    }, 6000);
  }

  // é™å¤œæ€ç‰¹æ•ˆåºåˆ—
  private triggerNightMoonEffects(): void {
    // "åºŠå‰æ˜æœˆå…‰" - æœˆå…‰ç²’å­ç¬¬ä¸€æ¬¡çˆ†å‘
    this.safeSetTimeout(() => {
      this.particleOpacity = 1.8; // å¢å¼ºç²’å­äº®åº¦
      this.moonBrightness = 0.9; // æœˆå…‰å¢å¼º
      console.log('âœ¨ åºŠå‰æ˜æœˆå…‰ - æœˆå…‰çˆ†å‘');
    }, 1500);
    
    // "ç–‘æ˜¯åœ°ä¸Šéœœ" - åœ°é¢éœœèŠ±é«˜äº®
    this.safeSetTimeout(() => {
      this.highlightFrost = true;
      this.particleOpacity = 1.5;
      console.log('â„ï¸ ç–‘æ˜¯åœ°ä¸Šéœœ - éœœé«˜äº®');
    }, 3500);
    
    // "ä¸¾å¤´æœ›æ˜æœˆ" - æœˆäº®æ”¾å¤§ 1.2 å€ï¼Œé•œå¤´ä¸Šç§»
    this.safeSetTimeout(() => {
      this.moonScale = 1.3; // æœˆäº®æ”¾å¤§
      this.moonY = 0.2; // é•œå¤´æ˜æ˜¾ä¸Šç§»
      this.highlightFrost = false; // å–æ¶ˆéœœé«˜äº®
      console.log('ğŸ”¼ ä¸¾å¤´æœ›æ˜æœˆ - æœˆäº®æ”¾å¤§+ä¸Šç§»');
    }, 5500);
    
    // "ä½å¤´æ€æ•…ä¹¡" - æç™½å‰ªå½±æ˜æ˜¾å‡ºç°
    this.safeSetTimeout(() => {
      this.libaiAlpha = 1.0; // æç™½å®Œå…¨æ˜¾ç¤º
      this.moonScale = 1.0; // æœˆäº®æ¢å¤
      this.moonY = 0.3; // æœˆäº®ä½ç½®æ¢å¤
      console.log('ğŸš¶ ä½å¤´æ€æ•…ä¹¡ - æç™½å‡ºç° (Alpha=1.0)');
    }, 7500);
    
    // 10ç§’åé‡ç½®ï¼Œå¾ªç¯æ•ˆæœ
    this.safeSetTimeout(() => {
      this.particleOpacity = 1.0;
      this.moonBrightness = 0.5;
      this.libaiAlpha = 0;
      this.moonScale = 1.0;
      console.log('ğŸ”„ é‡ç½®çŠ¶æ€ï¼Œå‡†å¤‡ä¸‹ä¸€è½®å¾ªç¯');
    }, 10000);
  }

  // æ°´è°ƒæ­Œå¤´ç‰¹æ•ˆåºåˆ— (ä¸­ç§‹å¤œ)
  private triggerMoonPalaceEffects(): void {
    // å¼€åœº: æœˆäº®ä»æµ·é¢è·ƒå‡º
    this.moonRiseProgress = 0;
    this.moonY = 1.0; // ä»æµ·å¹³é¢å¼€å§‹
    
    this.safeSetTimeout(() => {
      // æœˆäº®ä¸Šå‡åŠ¨ç”» (2ç§’å†…ä»æµ·é¢å‡åˆ°å¤©ç©º)
      this.safeSetInterval(() => {
        this.moonRiseProgress += 0.02;
        this.moonY = 1.0 - this.moonRiseProgress * 0.7; // ä»1.0å‡åˆ°0.3
        if (this.moonRiseProgress >= 1.0) {
          this.moonY = 0.3;
          this.palaceAlpha = 0.3; // æœˆå®«æ˜¾ç°
          // æœˆå®«å‡ºç°åï¼Œå«¦å¨¥ä¹Ÿå‡ºç°
          this.changEAlpha = 0.6;
        }
      }, 30);
    }, 500);
    
    // å«¦å¨¥é£è¡ŒåŠ¨ç”» (ä»æœˆå®«é£è¿‡)
    this.safeSetTimeout(() => {
      // å«¦å¨¥æ¸éš
      this.safeSetInterval(() => {
        this.changEAlpha -= 0.05;
        if (this.changEAlpha <= 0) {
          this.changEAlpha = 0;
        }
      }, 100);
      console.log('ğŸ‘° å«¦å¨¥ä»™å­é£è¿‡æœˆå®«');
    }, 4000);
    
    // "æ˜æœˆå‡ æ—¶æœ‰" - æ—¶é—´éš§é“ï¼Œå€’è®¡æ—¶3 2 1
    this.safeSetTimeout(() => {
      this.timeCountdown = 3;
      this.safeSetInterval(() => {
        this.timeCountdown--;
        if (this.timeCountdown <= 0) {
          this.timeCountdown = -1; // éšè—å€’è®¡æ—¶
        }
      }, 1000);
      console.log('ğŸ•’ æ˜æœˆå‡ æ—¶æœ‰ - æ—¶é—´éš§é“ 3-2-1');
    }, 3000);
    
    // "æŠŠé…’é—®é’å¤©" - è‹è½¼ä¸¾æ¯ï¼Œé…’æ¯å‡ºç°
    this.safeSetTimeout(() => {
      this.suShiAlpha = 0.9; // è‹è½¼å‡ºç°
      this.cupAlpha = 1.0; // é…’æ¯å‡ºç°
      console.log('ğŸ· æŠŠé…’é—®é’å¤© - è‹è½¼ä¸¾æ¯');
    }, 7000);
    
    // "èµ·èˆå¼„æ¸…å½±" - äººå½±åˆ†è£‚æˆ03ä¸ªï¼Œ360Â°æ—‹è½¬
    this.safeSetTimeout(() => {
      this.shadowCount = 3; // åˆ†è£‚æˆ3ä¸ªé‡å½±
      // æ—‹è½¬åŠ¨ç”»
      this.safeSetInterval(() => {
        this.shadowRotation += 10; // æ¯æ¬¡10åº¦
        if (this.shadowRotation >= 360) {
          this.shadowRotation = 0;
          this.shadowCount = 1; // æ¢å¤ä¸º1ä¸ª
        }
      }, 30);
      console.log('ğŸ’ƒ èµ·èˆå¼„æ¸…å½± - äººå½±åˆ†è£‚+æ—‹è½¬');
    }, 15000);
    
    // "ä½†æ„¿äººé•¿ä¹…" - æ‰€æœ‰å­”æ˜ç¯åŒæ—¶å‡ç©ºï¼Œæ‹¼æˆ"é•¿ä¹…"äºŒå­—
    this.safeSetTimeout(() => {
      this.lanternBurst = true;
      
      // å­”æ˜ç¯åˆ†æˆä¸¤ç»„ï¼Œåˆ†åˆ«æ‹¼æˆ"é•¿"å’Œ"ä¹…"
      const centerX: number = this.canvasWidth * 0.5;
      const centerY: number = this.canvasHeight * 0.35;
      const spacing: number = 100; // ä¸¤ä¸ªå­—çš„é—´è·
      
      // "é•¿"å­—çš„ä½ç½® (å·¦ä¾§)
      const changPositions: Position[] = [
        {x: centerX - spacing - 20, y: centerY - 30} as Position,
        {x: centerX - spacing, y: centerY - 20} as Position,
        {x: centerX - spacing + 20, y: centerY - 10} as Position,
        {x: centerX - spacing - 10, y: centerY + 10} as Position,
        {x: centerX - spacing + 10, y: centerY + 30} as Position
      ];
      
      // "ä¹…"å­—çš„ä½ç½® (å³ä¾§)
      const jiuPositions: Position[] = [
        {x: centerX   - 15, y: centerY - 25} as Position,
        {x: centerX , y: centerY - 10} as Position,
        {x: centerX  + 15, y: centerY} as Position,
        {x: centerX  - 10, y: centerY + 15} as Position,
        {x: centerX  + 10, y: centerY + 30} as Position
      ];
      
      // å°†å­”æ˜ç¯ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®
      this.lanterns.forEach((lantern: Lantern, index: number) => {
        if (index < 5) {
          // å‰5ä¸ªæ‹¼"é•¿"
          lantern.x = changPositions[index].x;
          lantern.y = changPositions[index].y;
        } else if (index < 10) {
          // å5ä¸ªæ‹¼"ä¹…"
          lantern.x = jiuPositions[index - 5].x;
          lantern.y = jiuPositions[index - 5].y;
        }
        lantern.vy = 0; // åœæ­¢ç§»åŠ¨
        lantern.isExploding = true;
        lantern.alpha = 1.0;
      });
      
      console.log('ğŸ† ä½†æ„¿äººé•¿ä¹… - å­”æ˜ç¯æ‹¼æˆ"é•¿ä¹…"äºŒå­—');
      
      // 2ç§’åé‡ç½®
      this.safeSetTimeout(() => {
        this.lanternBurst = false;
      }, 2000);
    }, 30000); // è°ƒæ•´ä¸º30ç§’,å¯¹åº”æœ—è¯»åˆ°"ä½†æ„¿äººé•¿ä¹…"(æœ€åä¸€å¥)
    
    // 30ç§’åé‡ç½®æ‰€æœ‰çŠ¶æ€ï¼Œå‡†å¤‡å¾ªç¯
    this.safeSetTimeout(() => {
      this.moonRiseProgress = 0;
      this.palaceAlpha = 0;
      this.changEAlpha = 0;
      this.suShiAlpha = 0;
      this.cupAlpha = 0;
      this.shadowCount = 1;
      this.shadowRotation = 0;
      this.timeCountdown = -1;
      this.lanternBurst = false;
      this.moonY = 0.3;
      console.log('ğŸ”„ æ°´è°ƒæ­Œå¤´é‡ç½®ï¼Œå‡†å¤‡ä¸‹ä¸€è½®');
    }, 34000);
  }
  
  // å¤©å‡€æ²™Â·ç§‹æ€ç‰¹æ•ˆåºåˆ— (é»„æ˜å¤é“)
  private triggerAutumnDuskEffects(): void {
    // å·è½´è‡ªåŠ¨æ»šåŠ¨
    this.safeSetInterval(() => {
      this.scrollOffset += 0.5;
      if (this.scrollOffset > this.canvasWidth) {
        this.scrollOffset = 0;
      }
    }, 30);
    
    // 0:00 "æ¯è—¤è€æ ‘æ˜é¸¦" - ä¹Œé¸¦ççœ¼å¹¶é£èµ·
    this.safeSetTimeout(() => {
      this.crowEyeOpen = true;
      this.safeSetTimeout(() => {
        this.crowsFlying = true;
        console.log('ğŸ¦… æ¯è—¤è€æ ‘æ˜é¸¦ - ä¹Œé¸¦ççœ¼é£èµ·');
      }, 500);
    }, 1000);
    
    // 0:08 "å°æ¡¥æµæ°´äººå®¶" - æ°´é¢æ³¢çº¹
    this.safeSetTimeout(() => {
      this.waterRipple = 1.0;
      console.log('ğŸŒŠ å°æ¡¥æµæ°´äººå®¶ - æ°´é¢æ³¢çº¹');
    }, 8000);
    
    // 0:16 "å¤é“è¥¿é£ç˜¦é©¬" - ç˜¦é©¬åœä¸‹ï¼Œé©¬å°¾æ‰«å‡º"å¤©æ¶¯"
    this.safeSetTimeout(() => {
      this.horseStop = true;
      this.safeSetTimeout(() => {
        this.tianyaText = true;
        console.log('ğŸ å¤é“è¥¿é£ç˜¦é©¬ - é©¬å°¾æ‰«å‡ºå¤©æ¶¯');
        // 3ç§’åæ–‡å­—æ¶ˆæ•£
        this.safeSetTimeout(() => {
          this.tianyaText = false;
        }, 3000);
      }, 1000);
    }, 10000);
    
    // 0:24 "å¤•é˜³è¥¿ä¸‹" - å¤ªé˜³åŠ é€Ÿè½å±±ï¼Œæš—è§’+å¿ƒè·³
    this.safeSetTimeout(() => {
      // å¤•é˜³ä¸‹æ²‰åŠ¨ç”»
      this.safeSetInterval(() => {
        this.sunsetProgress += 0.05;
        this.vignetteAlpha = this.sunsetProgress * 0.6;
        if (this.sunsetProgress >= 1.0) {
          // æ˜¾ç¤ºæ–­è‚ äººåœ¨å¤©æ¶¯
          this.duanchangText = true;
        }
      }, 100);
      console.log('ğŸŒ… å¤•é˜³è¥¿ä¸‹ - åŠ é€Ÿè½å±±+æš—è§’');
    }, 13000);
    
    // 30ç§’åé‡ç½®
    this.safeSetTimeout(() => {
      this.scrollOffset = 0;
      this.crowsFlying = false;
      this.crowEyeOpen = false;
      this.waterRipple = 0;
      this.horseStop = false;
      this.tianyaText = false;
      this.sunsetProgress = 0;
      this.vignetteAlpha = 0;
      this.duanchangText = false;
      console.log('ğŸ”„ å¤©å‡€æ²™Â·ç§‹æ€é‡ç½®ï¼Œå‡†å¤‡ä¸‹ä¸€è½®');
    }, 15000);
  }

  // æš‚åœ/ç»§ç»­æœ—è¯µ
  private togglePlay(): void {
    if (this.isPlaying) {
      TextReader.pause();
      this.isPlaying = false;
    } else {
      this.startRecitation();
    }
  }

  // åˆå§‹åŒ–ç²’å­
  private initParticles(): void {
    if (this.canvasWidth === 0 || this.canvasHeight === 0) {
      console.log('Cannot init particles: canvas size is 0');
      return;
    }
    
    const poem = this.livePoems[this.currentPoemIndex];
    this.particles = [];
    
    // æ ¹æ®åœºæ™¯è°ƒæ•´ç²’å­æ•°é‡
    let particleCount = 60;
    if (poem.scene === 'river_moon') {
      particleCount = 80; // æ˜¥æ±ŸèŠ±æœˆå¤œ - æ›´å¤šèŠ±ç“£
    } else if (poem.scene === 'night_moon') {
      particleCount = 30; // é™å¤œæ€ - å®é™å°‘é‡
    } else if (poem.scene === 'snow_river') {
      particleCount = 100; // æ±Ÿé›ª - å¤§é›ªçº·é£
    } else if (poem.scene === 'moon_palace') {
      particleCount = 50; // æ°´è°ƒæ­Œå¤´ - æ˜Ÿå°˜é—ªçƒ
    } else if (poem.scene === 'autumn_dusk') {
      particleCount = 70; // ç§‹æ€ - è½å¶çº·é£
    }
    
    for (let i = 0; i < particleCount; i++) {
      this.particles.push(this.createParticle());
    }
    
    console.log('Particles initialized:', this.particles.length, 'for scene:', poem.scene);
  }

  // åˆ›å»ºç²’å­
  private createParticle(): Particle {
    const poem = this.livePoems[this.currentPoemIndex];
    let color = '#FFD700'; // é»˜è®¤é‡‘è‰²
    let size = Math.random() * 4 + 2;
    let vx = (Math.random() - 0.5) * 2;
    let vy = Math.random() * 2 + 1;
    
    if (poem.scene === 'river_moon') {
      // æ˜¥æ±ŸèŠ±æœˆå¤œ - é‡‘è‰²èŠ±ç“£,æ¨ªå‘é£˜åŠ¨
      color = Math.random() > 0.7 ? '#FFD700' : '#FFC0CB'; // é‡‘è‰²/ç²‰è‰²èŠ±ç“£
      size = Math.random() * 5 + 3;
      vx = (Math.random() - 0.5) * 3; // æ›´å¤šæ¨ªå‘è¿åŠ¨
      vy = Math.random() * 1.5 + 0.5; // ç¼“æ…¢ä¸‹è½
    } else if (poem.scene === 'night_moon') {
      // é™å¤œæ€ - é“¶ç™½æœˆå…‰,ä»ä¸‹å¾€ä¸Šä¸Šå‡ (éœœç²’å­)
      color = 'rgba(255, 255, 255, 0.8)'; // é“¶ç™½è‰²
      size = Math.random() * 3 + 1;
      vx = (Math.random() - 0.5) * 0.5; // å‡ ä¹ä¸æ¨ªå‘ç§»åŠ¨
      vy = -(Math.random() * 0.8 + 0.3); // ä»ä¸‹å¾€ä¸Šä¸Šå‡ (è´Ÿå€¼)
    } else if (poem.scene === 'snow_river') {
      // æ±Ÿé›ª - ç™½è‰²é›ªèŠ±,é£˜æ´’ä¸‹è½
      color = '#FFFFFF';
      size = Math.random() * 6 + 3;
      vx = (Math.random() - 0.5) * 1.5; // é›ªèŠ±é£˜æ´’
      vy = Math.random() * 2 + 1;
    } else if (poem.scene === 'moon_palace') {
      // æ°´è°ƒæ­Œå¤´ - ä»™æ°”æ˜Ÿå°˜,å¾®å…‰é—ªçƒ
      color = Math.random() > 0.5 ? '#E0E0FF' : '#FFFACD'; // æ·¡ç´«/æ·¡é»„
      size = Math.random() * 2 + 1; // å¾®å°çš„æ˜Ÿå°˜
      vx = (Math.random() - 0.5) * 1;
      vy = Math.random() * 1 + 0.5; // æ¼‚æµ®æ„Ÿ
    } else if (poem.scene === 'autumn_dusk') {
      // ç§‹æ€ - çº¢è‰²æ«å¶,é‡‘é»„è½å¶
      color = Math.random() > 0.5 ? '#FF6B6B' : '#FFD700';
      size = Math.random() * 5 + 2;
      vx = (Math.random() - 0.5) * 3; // è¥¿é£å¹æ‹‚
      vy = Math.random() * 2 + 1.5; // è¾ƒå¿«ä¸‹è½
    }
    
    return {
      x: Math.random() * this.canvasWidth,
      y: Math.random() * this.canvasHeight,
      vx: vx,
      vy: vy,
      size: size,
      alpha: Math.random() * 0.5 + 0.5,
      color: color,
      life: 1.0
    };
  }

  // æ›´æ–°ç²’å­
  private updateParticles(): void {
    const poem = this.livePoems[this.currentPoemIndex];
    
    this.particles.forEach((p: Particle, index: number) => {
      // æ›´æ–°ä½ç½®
      p.x += p.vx;
      p.y += p.vy;
      
      // è¾¹ç•Œæ£€æµ‹
      if (poem.scene === 'night_moon') {
        // é™å¤œæ€ - ç²’å­ä¸Šå‡ï¼Œä»åº•éƒ¨é‡ç”Ÿ
        if (p.y < -10 || p.x < 0 || p.x > this.canvasWidth) {
          this.particles[index] = this.createParticle();
          this.particles[index].y = this.canvasHeight + 10; // ä»åº•éƒ¨å‡ºç°
        }
      } else {
        // å…¶ä»–åœºæ™¯ - ç²’å­ä¸‹é™ï¼Œä»é¡¶éƒ¨é‡ç”Ÿ
        if (p.y > this.canvasHeight || p.x < 0 || p.x > this.canvasWidth) {
          this.particles[index] = this.createParticle();
          this.particles[index].y = -10; // ä»é¡¶éƒ¨å‡ºç°
        }
      }
      
      // ç”Ÿå‘½å‘¨æœŸ
      p.life -= 0.001;
      if (p.life <= 0) {
        this.particles[index] = this.createParticle();
        if (poem.scene === 'night_moon') {
          this.particles[index].y = this.canvasHeight + 10;
        }
      }
    });
  }

  // æ›´æ–°å­”æ˜ç¯ (æ°´è°ƒæ­Œå¤´)
  private updateLanterns(): void {
    this.lanterns.forEach((lantern, index) => {
      // çˆ†ç‚¸åŠ¨ç”»
      if (lantern.isExploding) {
        lantern.explodeProgress += 0.02;
        if (lantern.explodeProgress >= 1.0) {
          lantern.isExploding = false;
          lantern.explodeProgress = 0;
          // é‡ç½®ä½ç½®
          lantern.y = this.canvasHeight + 100;
          lantern.x = Math.random() * this.canvasWidth;
          lantern.vy = -(Math.random() * 0.5 + 0.3);
        }
      } else if (!this.lanternBurst) {
        // åªæœ‰åœ¨éçˆ†ç‚¸çŠ¶æ€æ—¶æ‰æ­£å¸¸ç§»åŠ¨
        // æ›´æ–°ä½ç½®
        lantern.y += lantern.vy;
        
        // å¾®é£˜åŠ¨
        lantern.x += Math.sin(lantern.y * 0.01) * 0.5;
        
        // è¶…å‡ºå±å¹•é‡ç½®
        if (lantern.y < -50) {
          lantern.y = this.canvasHeight + Math.random() * 50;
          lantern.x = Math.random() * this.canvasWidth;
        }
      }
    });
  }
  
  // æ·»åŠ å­”æ˜ç¯ (æ°´è°ƒæ­Œå¤´ - ç‚¹å‡»äº¤äº’)
  private addLantern(x: number, y: number): void {
    this.lanterns.push({
      x: x,
      y: y,
      vy: -(Math.random() * 0.8 + 0.5), // ä¸Šå‡é€Ÿåº¦
      size: 15 + Math.random() * 10,
      alpha: 0.9,
      color: `rgba(255, ${180 + Math.random() * 50}, ${80 + Math.random() * 50}, 0.8)`,
      isExploding: false,
      explodeProgress: 0
    });
  }
  
  // åˆå§‹åŒ–å­”æ˜ç¯ (æ°´è°ƒæ­Œå¤´)
  private initLanterns(): void {
    this.lanterns = [];
    // åˆ›å»º 10 ä¸ªåˆå§‹å­”æ˜ç¯
    for (let i = 0; i < 10; i++) {
      this.lanterns.push({
        x: Math.random() * this.canvasWidth,
        y: this.canvasHeight * (0.6 + Math.random() * 0.4), // åœ¨ä¸‹åŠéƒ¨åˆ†
        vy: -(Math.random() * 0.5 + 0.3), // ç¼“æ…¢ä¸Šå‡
        size: 15 + Math.random() * 10,
        alpha: 0.8 + Math.random() * 0.2,
        color: `rgba(255, ${180 + Math.random() * 50}, ${80 + Math.random() * 50}, 0.8)`,
        isExploding: false,
        explodeProgress: 0
      });
    }
    console.log('ğŸ® åˆå§‹åŒ– 10 ä¸ªå­”æ˜ç¯');
  }

  // ç»˜åˆ¶åœºæ™¯
  private drawScene(): void {
    if (!this.context) {
      console.log('Context not ready');
      return;
    }
    
    if (this.canvasWidth === 0 || this.canvasHeight === 0) {
      console.log('Canvas size is 0');
      return;
    }
    
    const ctx = this.context;
    const poem = this.livePoems[this.currentPoemIndex];
    
    try {
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
      
      // ç»˜åˆ¶èƒŒæ™¯
      this.drawBackground(ctx, poem.scene);
      
      // ç»˜åˆ¶æœˆäº®
      if (poem.scene.includes('moon')) {
        this.drawMoon(ctx);
        // æ˜¥æ±ŸèŠ±æœˆå¤œ - ç»˜åˆ¶æœˆå…‰è·¯å¾„
        if (poem.scene === 'river_moon' && this.lightPathAlpha > 0) {
          this.drawMoonlightPath(ctx);
        }
      }
      
      // ç»˜åˆ¶æ°´æ³¢
      if (poem.scene.includes('river')) {
        this.drawWaves(ctx);
      }
      
      // ç»˜åˆ¶ç²’å­
      this.drawParticles(ctx);
      
      // æ›´æ–°æ³¢æµªåç§»
      this.waveOffset += 0.02;
    } catch (error) {
      console.error('Draw scene error:', error);
    }
  }

  // ç»˜åˆ¶èƒŒæ™¯
  private drawBackground(ctx: CanvasRenderingContext2D, scene: string): void {
    const gradient = ctx.createLinearGradient(0, 0, 0, this.canvasHeight);
    
    if (scene === 'river_moon') {
      // æ˜¥æ±ŸèŠ±æœˆå¤œ - æ˜¥æ±Ÿæ½®æ°´è¿æµ·å¹³,æµ·ä¸Šæ˜æœˆå…±æ½®ç”Ÿ
      // æ·±è“å¤œç©ºæ¸å˜åˆ°é’è‰²æ±Ÿæ°´
      gradient.addColorStop(0, '#0a1128'); // æ·±å¤œè“
      gradient.addColorStop(0.4, '#1e3a5f'); // å¤œç©ºè“
      gradient.addColorStop(0.7, '#2c5f7f'); // æ±Ÿæ°´è“
      gradient.addColorStop(1, '#3d7fa6'); // æµ…æ±Ÿè“
    } else if (scene === 'night_moon') {
      // é™å¤œæ€ - åºŠå‰æ˜æœˆå…‰,ç–‘æ˜¯åœ°ä¸Šéœœ
      // é»‘å¤œæˆ¿é—´,çª—æ£‚é€è¿›æœˆå…‰
      gradient.addColorStop(0, '#0a0a0f'); // æ·±é»‘å¤œ
      gradient.addColorStop(0.5, '#1a1a2e'); // æ·±ç´«å¤œ
      gradient.addColorStop(1, '#16213e'); // åº•éƒ¨ç¨äº®
    } else if (scene === 'snow_river') {
      // æ±Ÿé›ª - åƒå±±é¸Ÿé£ç»,ä¸‡å¾„äººè¸ªç­,å­¤èˆŸè“‘ç¬ ç¿,ç‹¬é’“å¯’æ±Ÿé›ª
      // å¯’å†·çš„é›ªæ™¯,ç°ç™½è‰²è°ƒ
      gradient.addColorStop(0, '#4a5568'); // ç°è‰²å¤©ç©º
      gradient.addColorStop(0.5, '#718096'); // é›ªäº‘
      gradient.addColorStop(1, '#cbd5e0'); // é›ªç™½æ±Ÿé¢
    } else if (scene === 'moon_palace') {
      // æ°´è°ƒæ­Œå¤´ - æ˜æœˆå‡ æ—¶æœ‰,æŠŠé…’é—®é’å¤©
      // æ¸…æ¾ˆçš„å¤œç©º,ä»™å¢ƒèˆ¬çš„æœˆå®«
      gradient.addColorStop(0, '#1e1e3f'); // æ·±ç´«å¤œ
      gradient.addColorStop(0.3, '#2d3561'); // ç´«è“å¤œç©º
      gradient.addColorStop(0.7, '#3e4a7a'); // å¤©ç©ºè“ç´«
      gradient.addColorStop(1, '#4a5f8f'); // æµ…è“
    } else if (scene === 'autumn_dusk') {
      // å¤©å‡€æ²™Â·ç§‹æ€ - æ¯è—¤è€æ ‘æ˜é¸¦,å°æ¡¥æµæ°´äººå®¶,å¤é“è¥¿é£ç˜¦é©¬,å¤•é˜³è¥¿ä¸‹
      // ç§‹æ—¥é»„æ˜,æš–æ©™åˆ°æ·±è“
      gradient.addColorStop(0, '#ff6b6b'); // å¤•é˜³çº¢
      gradient.addColorStop(0.3, '#ffa500'); // æ©™é»„
      gradient.addColorStop(0.6, '#ff8c42'); // æš–æ©™
      gradient.addColorStop(1, '#3d5a80'); // æš®è‰²è“ç°
    } else {
      // é»˜è®¤å¤©ç©º
      gradient.addColorStop(0, '#1e3a8a');
      gradient.addColorStop(1, '#3b82f6');
    }
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
    
    // æ ¹æ®åœºæ™¯æ·»åŠ ç‰¹æ®Šæ•ˆæœ
    if (scene === 'river_moon') {
      // æ˜¥æ±ŸèŠ±æœˆå¤œ - æ·»åŠ æ±Ÿé¢æ³¢å…‰
      this.drawRiverShimmer(ctx);
      // ç»˜åˆ¶è¿œå±±è§†å·®å±‚
      this.drawMountainLayers(ctx);
      // ç»˜åˆ¶æ½®æ°´æ•ˆæœ
      if (this.tideHeight > 0) {
        this.drawTideWater(ctx);
      }
    } else if (scene === 'night_moon') {
      // é™å¤œæ€ - ç»˜åˆ¶æˆ¿é—´ã€çª—æˆ·ã€æç™½å‰ªå½±
      this.drawNightRoom(ctx);
    } else if (scene === 'moon_palace') {
      // æ°´è°ƒæ­Œå¤´ - ç»˜åˆ¶ä¸­ç§‹å¤œåœºæ™¯
      this.drawMoonPalace(ctx);
    } else if (scene === 'snow_river') {
      // æ±Ÿé›ª - æ·»åŠ é›ªå±±å‰ªå½±
      this.drawSnowMountains(ctx);
    } else if (scene === 'autumn_dusk') {
      // ç§‹æ€ - æ·»åŠ æ¯æ ‘å‰ªå½±
      this.drawAutumnTrees(ctx);
    }
  }

  // ç»˜åˆ¶æœˆäº®
  private drawMoon(ctx: CanvasRenderingContext2D): void {
    const x = this.moonX * this.canvasWidth;
    const y = this.moonY * this.canvasHeight;
    const baseRadius = 50;
    const radius = baseRadius * this.moonScale;  // åº”ç”¨ç¼©æ”¾æ¯”ä¾‹
    
    // æœˆäº®å…‰æ™•
    const haloGradient = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2);
    haloGradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
    haloGradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
    haloGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
    
    ctx.fillStyle = haloGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // æœˆäº®æœ¬ä½“
    const moonGradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
    moonGradient.addColorStop(0, '#fffacd');
    moonGradient.addColorStop(1, '#f0e68c');
    
    ctx.fillStyle = moonGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  // ç»˜åˆ¶æ°´æ³¢
  private drawWaves(ctx: CanvasRenderingContext2D): void {
    const poem = this.livePoems[this.currentPoemIndex];
    const waveHeight = 30;
    const waveCount = 3;
    const baseY = this.canvasHeight * 0.75;
    
    for (let i = 0; i < waveCount; i++) {
      ctx.beginPath();
      ctx.moveTo(0, baseY + i * 20);
      
      for (let x = 0; x <= this.canvasWidth; x += 10) {
        const y = baseY + i * 20 + Math.sin((x + this.waveOffset * 100) * 0.02) * waveHeight;
        ctx.lineTo(x, y);
      }
      
      ctx.lineTo(this.canvasWidth, this.canvasHeight);
      ctx.lineTo(0, this.canvasHeight);
      ctx.closePath();
      
      const alpha = 0.3 - i * 0.1;
      // æ ¹æ®åœºæ™¯è°ƒæ•´æ°´æ³¢é¢œè‰²
      if (poem.scene === 'river_moon') {
        ctx.fillStyle = `rgba(61, 127, 166, ${alpha})`; // é’è“æ±Ÿæ°´
      } else {
        ctx.fillStyle = `rgba(100, 149, 237, ${alpha})`; // é»˜è®¤è“è‰²
      }
      ctx.fill();
    }
  }
  
  // ç»˜åˆ¶æ±Ÿé¢æ³¢å…‰ (æ˜¥æ±ŸèŠ±æœˆå¤œ)
  private drawRiverShimmer(ctx: CanvasRenderingContext2D): void {
    const baseY = this.canvasHeight * 0.75;
    const shimmerCount = 5;
    
    for (let i = 0; i < shimmerCount; i++) {
      const x = (i / shimmerCount) * this.canvasWidth + (this.waveOffset * 50) % this.canvasWidth;
      const y = baseY + Math.sin(this.waveOffset * 2 + i) * 10;
      
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 30);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
      gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // ç»˜åˆ¶æœˆå…‰è·¯å¾„ (æ˜¥æ±ŸèŠ±æœˆå¤œ - æ»šæº­éšæ³¢åƒä¸‡é‡Œ)
  private drawMoonlightPath(ctx: CanvasRenderingContext2D): void {
    const moonX = this.moonX * this.canvasWidth;
    const moonY = this.moonY * this.canvasHeight;
    const pathY = this.canvasHeight * 0.75; // æ±Ÿé¢é«˜åº¦
    
    ctx.save();
    ctx.globalAlpha = this.lightPathAlpha;
    
    // ç»˜åˆ¶ä»æœˆäº®åˆ°æ±Ÿé¢çš„å…‰è·¯
    const gradient = ctx.createLinearGradient(moonX, moonY, moonX, pathY);
    gradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
    gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.3)');
    gradient.addColorStop(1, 'rgba(255, 255, 200, 0.5)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(moonX - 30, moonY);
    ctx.lineTo(moonX + 30, moonY);
    ctx.lineTo(moonX + 50, pathY);
    ctx.lineTo(moonX - 50, pathY);
    ctx.closePath();
    ctx.fill();
    
    // ç»˜åˆ¶æ±Ÿé¢ä¸Šçš„æ³¢å…‰ç‚¹
    for (let i = 0; i < 20; i++) {
      const x = moonX - 40 + Math.random() * 80;
      const y = pathY + Math.random() * 50;
      const size = Math.random() * 3 + 1;
      
      ctx.fillStyle = `rgba(255, 255, 200, ${Math.random() * 0.5})`;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // ç»˜åˆ¶é™å¤œæ€æˆ¿é—´åœºæ™¯ (å…¨æ–°è®¾è®¡)
  private drawNightRoom(ctx: CanvasRenderingContext2D): void {
    // 1. ç»˜åˆ¶åœ°é¢ (åºŠå‰çš„åœ°æ¿)
    const floorY = this.canvasHeight * 0.7;
    const floorGradient = ctx.createLinearGradient(0, floorY, 0, this.canvasHeight);
    floorGradient.addColorStop(0, 'rgba(30, 30, 40, 0.8)'); // æˆ¿é—´åœ°æ¿
    floorGradient.addColorStop(1, 'rgba(20, 20, 30, 0.9)'); // æ›´æš—çš„åœ°é¢
    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, floorY, this.canvasWidth, this.canvasHeight - floorY);
    
    // 2. ç»˜åˆ¶åœ°é¢éœœèŠ±æ•ˆæœ (ç–‘æ˜¯åœ°ä¸Šéœœ) - ä¼˜åŒ–ç‰ˆ
    if (this.highlightFrost || this.moonBrightness > 0.6) {
      const frostAlpha = this.highlightFrost ? 0.6 : this.moonBrightness * 0.3;
      
      // ç»˜åˆ¶æ›´ç²¾è‡´çš„éœœèŠ±ç»“æ™¶
      for (let i = 0; i < 15; i++) {
        const x = (i / 15) * this.canvasWidth * 0.8 + this.canvasWidth * 0.1;
        const y = floorY + 30 + (i % 3) * 25 + Math.sin(this.waveOffset + i) * 10;
        
        // éœœèŠ±ä¸­å¿ƒç‚¹ï¼ˆæ›´äº®ï¼‰
        const centerGradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
        centerGradient.addColorStop(0, `rgba(240, 250, 255, ${frostAlpha * 1.2})`);
        centerGradient.addColorStop(0.6, `rgba(220, 235, 250, ${frostAlpha * 0.6})`);
        centerGradient.addColorStop(1, 'rgba(200, 220, 240, 0)');
        ctx.fillStyle = centerGradient;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶éœœèŠ±çš„å…­è¾¹å½¢ç»“æ™¶çº¹ç†
        ctx.save();
        ctx.translate(x, y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${frostAlpha * 0.7})`;
        ctx.lineWidth = 0.8;
        
        // ç»˜åˆ¶6æ¡æ”¾å°„çŠ¶å†°æ™¶çº¿
        for (let angle = 0; angle < 360; angle += 60) {
          const rad = (angle * Math.PI) / 180;
          const length = 12 + Math.random() * 6;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(rad) * length, Math.sin(rad) * length);
          ctx.stroke();
          
          // åœ¨æ¯æ¡çº¿çš„æœ«ç«¯æ·»åŠ å°åˆ†æ”¯
          const branchAngle1 = rad + Math.PI / 6;
          const branchAngle2 = rad - Math.PI / 6;
          const branchLen = 4;
          
          ctx.beginPath();
          ctx.moveTo(Math.cos(rad) * length, Math.sin(rad) * length);
          ctx.lineTo(
            Math.cos(rad) * length + Math.cos(branchAngle1) * branchLen,
            Math.sin(rad) * length + Math.sin(branchAngle1) * branchLen
          );
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(Math.cos(rad) * length, Math.sin(rad) * length);
          ctx.lineTo(
            Math.cos(rad) * length + Math.cos(branchAngle2) * branchLen,
            Math.sin(rad) * length + Math.sin(branchAngle2) * branchLen
          );
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      // æ·»åŠ ç»†å°çš„éœœèŠ±ç²‰å°˜æ•ˆæœ
      for (let i = 0; i < 30; i++) {
        const px = Math.random() * this.canvasWidth;
        const py = floorY + 20 + Math.random() * 100;
        const size = 1 + Math.random() * 2;
        
        ctx.fillStyle = `rgba(240, 250, 255, ${frostAlpha * 0.4 * Math.random()})`;
        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // 3. ç»˜åˆ¶çª—æˆ· (å·¦ä¸‹æ–¹)
    const windowX = this.canvasWidth * 0.05;  // å·¦ä¾§ç•™å°ç•™ç™½
    const windowY = this.canvasHeight * 0.45;  // ä¸­ä¸‹éƒ¨ä½ç½®
    const windowW = this.canvasWidth * 0.3;
    const windowH = this.canvasHeight * 0.35;
    
    // çª—å¤–å¤œç©º (æ·±è“è‰²)
    ctx.fillStyle = 'rgba(10, 20, 40, 0.6)';
    ctx.fillRect(windowX, windowY, windowW, windowH);
    
    // çª—å¤–æœˆå…‰ (æ ¹æ®moonBrightness)
    const moonlightAlpha = this.moonBrightness * 0.5;
    const moonlightGradient = ctx.createRadialGradient(
      windowX + windowW * 0.6, windowY + windowH * 0.3, 0,
      windowX + windowW * 0.6, windowY + windowH * 0.3, windowW * 0.8
    );
    moonlightGradient.addColorStop(0, `rgba(255, 255, 220, ${moonlightAlpha})`);
    moonlightGradient.addColorStop(0.5, `rgba(200, 200, 150, ${moonlightAlpha * 0.5})`);
    moonlightGradient.addColorStop(1, 'rgba(200, 200, 150, 0)');
    ctx.fillStyle = moonlightGradient;
    ctx.fillRect(windowX, windowY, windowW, windowH);
    
    // çª—æ¡† (æœ¨åˆ¶çª—æ¡†)
    ctx.strokeStyle = 'rgba(60, 50, 40, 0.9)';
    ctx.lineWidth = 6;
    ctx.strokeRect(windowX, windowY, windowW, windowH);
    
    // çª—æ£‚ (åå­—åˆ†å‰²)
    ctx.lineWidth = 3;
    // ç«–çº¿
    ctx.beginPath();
    ctx.moveTo(windowX + windowW / 2, windowY);
    ctx.lineTo(windowX + windowW / 2, windowY + windowH);
    ctx.stroke();
    // æ¨ªçº¿
    ctx.beginPath();
    ctx.moveTo(windowX, windowY + windowH / 2);
    ctx.lineTo(windowX + windowW, windowY + windowH / 2);
    ctx.stroke();
    
    // 4. çª—å¤–è¿œå±±å‰ªå½±
    ctx.fillStyle = 'rgba(20, 30, 50, 0.5)';
    ctx.beginPath();
    ctx.moveTo(windowX, windowY + windowH * 0.5);
    ctx.lineTo(windowX + windowW * 0.3, windowY + windowH * 0.4);
    ctx.lineTo(windowX + windowW * 0.5, windowY + windowH * 0.45);
    ctx.lineTo(windowX + windowW * 0.7, windowY + windowH * 0.38);
    ctx.lineTo(windowX + windowW, windowY + windowH * 0.5);
    ctx.lineTo(windowX + windowW, windowY + windowH);
    ctx.lineTo(windowX, windowY + windowH);
    ctx.closePath();
    ctx.fill();
    
    // 5. ç»˜åˆ¶æç™½å‰ªå½± (ç«™åœ¨çª—å‰)
    if (this.libaiAlpha > 0) {
      this.drawLibaiSilhouette(ctx);
    }
    
    // 6. ç»˜åˆ¶å­¤é› (çª—å¤–é£è¿‡)
    if (this.showGoose) {
      // è°ƒæ•´å­¤é›ä½ç½®åˆ°çª—æˆ·åŒºåŸŸ
      const gooseInWindow = this.gooseX > windowX && this.gooseX < windowX + windowW &&
                           this.gooseY > windowY && this.gooseY < windowY + windowH;
      if (gooseInWindow) {
        this.drawGoose(ctx);
      }
    }
    
    // 7. æœˆå…‰æŠ•å°„åˆ°åœ°é¢çš„å…‰æŸ
    if (this.moonBrightness > 0.4) {
      const lightBeam = ctx.createLinearGradient(
        windowX + windowW * 0.5, windowY + windowH,
        windowX - windowW * 0.3, floorY + 50
      );
      lightBeam.addColorStop(0, `rgba(255, 255, 220, ${this.moonBrightness * 0.15})`);
      lightBeam.addColorStop(1, 'rgba(255, 255, 220, 0)');
      ctx.fillStyle = lightBeam;
      ctx.beginPath();
      ctx.moveTo(windowX + windowW * 0.3, windowY + windowH);
      ctx.lineTo(windowX + windowW * 0.7, windowY + windowH);
      ctx.lineTo(windowX, floorY + 80);
      ctx.lineTo(windowX - windowW * 0.5, floorY + 80);
      ctx.closePath();
      ctx.fill();
    }
  }
  
  // ç»˜åˆ¶çª—æ£‚
  private drawWindow(ctx: CanvasRenderingContext2D): void {
    const windowX = this.canvasWidth * 0.7;
    const windowY = this.canvasHeight * 0.15;
    const windowW = this.canvasWidth * 0.25;
    const windowH = this.canvasHeight * 0.3;
    
    // çª—æ¡†
    ctx.strokeStyle = 'rgba(40, 40, 50, 0.8)';
    ctx.lineWidth = 4;
    ctx.strokeRect(windowX, windowY, windowW, windowH);
    
    // çª—æ£‚ (åå­—åˆ†å‰²)
    ctx.lineWidth = 2;
    // ç«–çº¿
    ctx.beginPath();
    ctx.moveTo(windowX + windowW / 2, windowY);
    ctx.lineTo(windowX + windowW / 2, windowY + windowH);
    ctx.stroke();
    // æ¨ªçº¿
    ctx.beginPath();
    ctx.moveTo(windowX, windowY + windowH / 2);
    ctx.lineTo(windowX + windowW, windowY + windowH / 2);
    ctx.stroke();
    
    // çª—å¤–æœˆå…‰ (å‘¼å¸æ•ˆæœ)
    const moonlightAlpha = this.moonBrightness * 0.3;
    ctx.fillStyle = `rgba(200, 200, 150, ${moonlightAlpha})`;
    ctx.fillRect(windowX, windowY, windowW, windowH);
  }
  
  // ç»˜åˆ¶æç™½å‰ªå½± (å¢å¼ºç‰ˆ - æ›´æ˜æ˜¾)
  private drawLibaiSilhouette(ctx: CanvasRenderingContext2D): void {
    const centerX = this.canvasWidth * 0.5; // è°ƒæ•´ä½ç½®ï¼Œç«™åœ¨çª—æˆ·å³ä¾§
    const bottomY = this.canvasHeight * 0.8; // è°ƒæ•´é«˜åº¦
    
    ctx.save();
    ctx.globalAlpha = this.libaiAlpha;
    ctx.fillStyle = 'rgba(10, 10, 20, 0.95)'; // æ›´æ·±çš„é»‘è‰²
    
    // å¤´éƒ¨ - æ›´å¤§
    ctx.beginPath();
    ctx.arc(centerX, bottomY - 90, 20, 0, Math.PI * 2); // åŠå¾„ä»15å¢åŠ åˆ°20
    ctx.fill();
    
    // å¤´å·¾ (å¤ä»£æ–‡äººå½¢è±¡)
    ctx.beginPath();
    ctx.moveTo(centerX - 22, bottomY - 90);
    ctx.lineTo(centerX - 18, bottomY - 100);
    ctx.lineTo(centerX + 18, bottomY - 100);
    ctx.lineTo(centerX + 22, bottomY - 90);
    ctx.closePath();
    ctx.fill();
    
    // èº«ä½“ - æ›´å®½
    ctx.beginPath();
    ctx.moveTo(centerX - 30, bottomY - 70); // ä»-20å¢åŠ åˆ°-30
    ctx.lineTo(centerX - 35, bottomY);
    ctx.lineTo(centerX + 35, bottomY);
    ctx.lineTo(centerX + 30, bottomY - 70);
    ctx.closePath();
    ctx.fill();
    
    // å·¦è‡‚ (ä½å¤´æ€æ•…ä¹¡çš„å§¿æ€)
    ctx.beginPath();
    ctx.moveTo(centerX - 30, bottomY - 65);
    ctx.lineTo(centerX - 50, bottomY - 50);
    ctx.lineTo(centerX - 45, bottomY - 30);
    ctx.closePath();
    ctx.fill();
    
    // å³è‡‚ (æŠ±è‡‚å§¿æ€)
    ctx.beginPath();
    ctx.moveTo(centerX + 30, bottomY - 65);
    ctx.lineTo(centerX + 45, bottomY - 55);
    ctx.lineTo(centerX + 40, bottomY - 35);
    ctx.closePath();
    ctx.fill();
    
    // æ·»åŠ è½®å»“å‘å…‰æ•ˆæœ
    ctx.strokeStyle = `rgba(200, 200, 150, ${this.libaiAlpha * 0.3})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.restore();
  }
  
  // ç»˜åˆ¶å­¤é›
  private drawGoose(ctx: CanvasRenderingContext2D): void {
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = 'rgba(100, 100, 120, 0.8)';
    ctx.lineWidth = 2;
    
    // Vå­—å½¢çš„é›å½¢
    ctx.beginPath();
    ctx.moveTo(this.gooseX - 8, this.gooseY - 5);
    ctx.lineTo(this.gooseX, this.gooseY);
    ctx.lineTo(this.gooseX + 8, this.gooseY - 5);
    ctx.stroke();
    
    ctx.restore();
  }
  
  // ç»˜åˆ¶è¿œå±±è§†å·®å±‚ (æ˜¥æ±ŸèŠ±æœˆå¤œ)
  private drawMountainLayers(ctx: CanvasRenderingContext2D): void {
    // è¿œå±±å±‚ - é¢œè‰²æ›´æš—ã€æ›´é ä¸Š
    ctx.fillStyle = 'rgba(20, 40, 70, 0.6)';
    ctx.beginPath();
    ctx.moveTo(0, this.canvasHeight * 0.35);
    ctx.lineTo(this.canvasWidth * 0.25, this.canvasHeight * 0.3);
    ctx.lineTo(this.canvasWidth * 0.5, this.canvasHeight * 0.33);
    ctx.lineTo(this.canvasWidth * 0.75, this.canvasHeight * 0.28);
    ctx.lineTo(this.canvasWidth, this.canvasHeight * 0.32);
    ctx.lineTo(this.canvasWidth, this.canvasHeight);
    ctx.lineTo(0, this.canvasHeight);
    ctx.closePath();
    ctx.fill();

    // ä¸­å±±å±‚ - é¢œè‰²ç•¥äº®
    ctx.fillStyle = 'rgba(30, 60, 100, 0.5)';
    ctx.beginPath();
    ctx.moveTo(0, this.canvasHeight * 0.45);
    ctx.lineTo(this.canvasWidth * 0.2, this.canvasHeight * 0.4);
    ctx.lineTo(this.canvasWidth * 0.45, this.canvasHeight * 0.43);
    ctx.lineTo(this.canvasWidth * 0.7, this.canvasHeight * 0.38);
    ctx.lineTo(this.canvasWidth, this.canvasHeight * 0.42);
    ctx.lineTo(this.canvasWidth, this.canvasHeight);
    ctx.lineTo(0, this.canvasHeight);
    ctx.closePath();
    ctx.fill();

    // è¿‘å±±å±‚ - é¢œè‰²æœ€äº®
    ctx.fillStyle = 'rgba(40, 80, 130, 0.4)';
    ctx.beginPath();
    ctx.moveTo(0, this.canvasHeight * 0.55);
    ctx.lineTo(this.canvasWidth * 0.18, this.canvasHeight * 0.5);
    ctx.lineTo(this.canvasWidth * 0.4, this.canvasHeight * 0.53);
    ctx.lineTo(this.canvasWidth * 0.65, this.canvasHeight * 0.49);
    ctx.lineTo(this.canvasWidth, this.canvasHeight * 0.52);
    ctx.lineTo(this.canvasWidth, this.canvasHeight);
    ctx.lineTo(0, this.canvasHeight);
    ctx.closePath();
    ctx.fill();
  }

  // ç»˜åˆ¶æ½®æ°´ (æ½®æ±å¼•åŠ› + æœ—è¯µéŸ³é‡æ¨¡æ‹Ÿ)
  private drawTideWater(ctx: CanvasRenderingContext2D): void {
    const baseY = this.canvasHeight * 0.75;
    const tide = baseY - this.tideHeight * 60; // æ½®æ°´é«˜åº¦æ”¹å˜
    ctx.fillStyle = 'rgba(61, 127, 166, 0.4)';
    ctx.beginPath();
    ctx.moveTo(0, tide);
    for (let x = 0; x <= this.canvasWidth; x += 8) {
      const y = tide + Math.sin((x + this.waveOffset * 120) * 0.02) * 8;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(this.canvasWidth, this.canvasHeight);
    ctx.lineTo(0, this.canvasHeight);
    ctx.closePath();
    ctx.fill();
  }

  // ç»˜åˆ¶é›ªå±±å‰ªå½± (æ±Ÿé›ª)
  private drawSnowMountains(ctx: CanvasRenderingContext2D): void {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    
    // è¿œå±±
    ctx.beginPath();
    ctx.moveTo(0, this.canvasHeight * 0.6);
    ctx.lineTo(this.canvasWidth * 0.3, this.canvasHeight * 0.4);
    ctx.lineTo(this.canvasWidth * 0.5, this.canvasHeight * 0.5);
    ctx.lineTo(this.canvasWidth * 0.7, this.canvasHeight * 0.35);
    ctx.lineTo(this.canvasWidth, this.canvasHeight * 0.55);
    ctx.lineTo(this.canvasWidth, this.canvasHeight);
    ctx.lineTo(0, this.canvasHeight);
    ctx.closePath();
    ctx.fill();
    
    // å°èˆ¹ - å­¤èˆŸè“‘ç¬ ç¿
    const boatX = this.canvasWidth * 0.7;
    const boatY = this.canvasHeight * 0.8;
    ctx.fillStyle = 'rgba(80, 80, 80, 0.6)';
    ctx.beginPath();
    ctx.moveTo(boatX - 15, boatY);
    ctx.lineTo(boatX + 15, boatY);
    ctx.lineTo(boatX + 10, boatY + 5);
    ctx.lineTo(boatX - 10, boatY + 5);
    ctx.closePath();
    ctx.fill();
  }

  // ç»˜åˆ¶ç§‹å¤©æ¯æ ‘ (ç§‹æ€)
  private drawAutumnTrees(ctx: CanvasRenderingContext2D): void {
    // è°ƒç”¨å®Œæ•´çš„ç§‹æ€åœºæ™¯
    this.drawAutumnDuskScene(ctx);
  }
  
  // ç»˜åˆ¶å¤©å‡€æ²™Â·ç§‹æ€å®Œæ•´åœºæ™¯ (é»„æ˜å¤é“)
  private drawAutumnDuskScene(ctx: CanvasRenderingContext2D): void {
    ctx.save();
    
    // 1. ç»˜åˆ¶å·è½´èƒŒæ™¯ (æ¨ªå‘æ»šåŠ¨)
    ctx.translate(-this.scrollOffset, 0);
    
    // 2. ç»˜åˆ¶å¤•é˜³
    const sunX: number = this.canvasWidth * 0.8 + this.scrollOffset;
    const sunY: number = this.canvasHeight * (0.2 + this.sunsetProgress * 0.3); // ä¸‹æ²‰
    const sunRadius: number = 40;
    
    const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
    sunGradient.addColorStop(0, 'rgba(255, 150, 50, 0.9)');
    sunGradient.addColorStop(0.7, 'rgba(255, 100, 30, 0.6)');
    sunGradient.addColorStop(1, 'rgba(255, 80, 20, 0)');
    ctx.fillStyle = sunGradient;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // 3. ç»˜åˆ¶æ¯è—¤è€æ ‘
    const treeX: number = this.canvasWidth * 0.2 + this.scrollOffset;
    this.drawDeadTree(ctx, treeX, this.canvasHeight * 0.7, 60);
    
    // 4. ç»˜åˆ¶æ˜é¸¦
    if (this.crowEyeOpen || this.crowsFlying) {
      this.drawCrows(ctx, treeX + 20, this.canvasHeight * 0.5);
    }
    
    // 5. ç»˜åˆ¶å°æ¡¥æµæ°´
    const bridgeX: number = this.canvasWidth * 0.5 + this.scrollOffset;
    this.drawBridgeAndWater(ctx, bridgeX, this.canvasHeight * 0.75);
    
    // 6. ç»˜åˆ¶å¤é“è¥¿é£ç˜¦é©¬
    const horseX: number = this.canvasWidth * 0.7 + this.scrollOffset;
    this.drawHorse(ctx, horseX, this.canvasHeight * 0.65);
    
    ctx.restore();
    
    // 7. ç»˜åˆ¶æš—è§’ (ä¸å—å·è½´å½±å“)
    if (this.vignetteAlpha > 0) {
      this.drawVignette(ctx);
    }
    
    // 8. ç»˜åˆ¶æ–‡å­—ç‰¹æ•ˆ
    if (this.tianyaText) {
      this.drawTianyaText(ctx);
    }
    
    if (this.duanchangText) {
      this.drawDuanchangText(ctx);
    }
  }
  
  // ç»˜åˆ¶æ¯æ ‘
  private drawDeadTree(ctx: CanvasRenderingContext2D, x: number, y: number, height: number): void {
    ctx.strokeStyle = 'rgba(60, 40, 30, 0.8)';
    ctx.lineWidth = 4;
    
    // æ ‘å¹²
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y - height);
    ctx.stroke();
    
    // æ¯è—¤ç¼ ç»•
    ctx.strokeStyle = 'rgba(80, 60, 40, 0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(x - 5, y - i * 20);
      ctx.bezierCurveTo(
        x + 10, y - i * 20 - 10,
        x - 10, y - i * 20 - 20,
        x + 5, y - i * 20 - 30
      );
      ctx.stroke();
    }
    
    // ææƒ
    const branchCount: number = 4;
    ctx.strokeStyle = 'rgba(60, 40, 30, 0.7)';
    ctx.lineWidth = 3;
    for (let i = 0; i < branchCount; i++) {
      const branchY: number = y - height * (0.4 + i * 0.2);
      const branchLength: number = height * (0.4 - i * 0.08);
      
      ctx.beginPath();
      ctx.moveTo(x, branchY);
      ctx.lineTo(x - branchLength, branchY - branchLength * 0.3);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(x, branchY);
      ctx.lineTo(x + branchLength * 0.7, branchY - branchLength * 0.4);
      ctx.stroke();
    }
  }
  
  // ç»˜åˆ¶ä¹Œé¸¦
  private drawCrows(ctx: CanvasRenderingContext2D, x: number, y: number): void {
    const crowCount: number = 3;
    
    for (let i = 0; i < crowCount; i++) {
      const crowX: number = x + i * 25;
      const crowY: number = y + Math.sin(Date.now() * 0.003 + i) * 5;
      
      ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
      
      if (this.crowsFlying) {
        // é£è¡ŒçŠ¶æ€
        const flyOffset: number = (Date.now() * 0.1 + i * 100) % this.canvasWidth;
        const finalX: number = crowX + flyOffset;
        const finalY: number = crowY - flyOffset * 0.3;
        
        // ç®€åŒ–çš„é£é¸Ÿå½¢çŠ¶
        ctx.beginPath();
        ctx.moveTo(finalX - 8, finalY);
        ctx.lineTo(finalX - 3, finalY - 3);
        ctx.lineTo(finalX, finalY);
        ctx.lineTo(finalX + 3, finalY - 3);
        ctx.lineTo(finalX + 8, finalY);
        ctx.stroke();
      } else {
        // åœæ­¢çŠ¶æ€
        ctx.beginPath();
        ctx.arc(crowX, crowY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // ç¡çœ¼ (çº¢ç‚¹)
        if (this.crowEyeOpen) {
          ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
          ctx.beginPath();
          ctx.arc(crowX + 2, crowY, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }
  
  // ç»˜åˆ¶å°æ¡¥å’Œæµæ°´
  private drawBridgeAndWater(ctx: CanvasRenderingContext2D, x: number, y: number): void {
    // å°æ¡¥
    ctx.strokeStyle = 'rgba(100, 80, 60, 0.7)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, 40, Math.PI, 0);
    ctx.stroke();
    
    // æµæ°´åŒºåŸŸ
    const waterY: number = y + 10;
    const waterWidth: number = 120;
    const waterHeight: number = 30;
    
    // ç»˜åˆ¶æ°´é¢æ¸å˜
    const waterGradient = ctx.createLinearGradient(x - waterWidth/2, waterY, x - waterWidth/2, waterY + waterHeight);
    waterGradient.addColorStop(0, 'rgba(100, 150, 180, 0.4)');
    waterGradient.addColorStop(1, 'rgba(80, 130, 160, 0.5)');
    ctx.fillStyle = waterGradient;
    ctx.fillRect(x - waterWidth/2, waterY, waterWidth, waterHeight);
    
    // æ°´æ³¢çº¹æ•ˆæœ (æ¨ªå‘æ³¢æµªçº¿)
    if (this.waterRipple > 0) {
      ctx.save();
      
      // ç»˜åˆ¶å¤šå±‚æ³¢çº¹çº¿
      for (let i = 0; i < 5; i++) {
        const waveY: number = waterY + 5 + i * 6;
        const amplitude: number = 2 + i * 0.5; // æ³¢æµªæŒ¯å¹…
        const frequency: number = 0.1; // æ³¢æµªé¢‘ç‡
        const phase: number = this.waveOffset * 2 + i * 0.5; // ç›¸ä½åç§»
        const alpha: number = (0.5 - i * 0.08) * this.waterRipple;
        
        ctx.strokeStyle = `rgba(150, 200, 220, ${alpha})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        // ç»˜åˆ¶æ³¢æµªæ›²çº¿
        for (let wx = x - waterWidth/2; wx <= x + waterWidth/2; wx += 2) {
          const wy = waveY + Math.sin((wx - x) * frequency + phase) * amplitude;
          if (wx === x - waterWidth/2) {
            ctx.moveTo(wx, wy);
          } else {
            ctx.lineTo(wx, wy);
          }
        }
        ctx.stroke();
      }
      
      // æ·»åŠ ä¸€äº›æ³¢å…‰ç‚¹
      for (let i = 0; i < 8; i++) {
        const dotX: number = x - waterWidth/2 + Math.random() * waterWidth;
        const dotY: number = waterY + Math.random() * waterHeight;
        const dotSize: number = 1 + Math.random() * 2;
        const dotAlpha: number = Math.random() * 0.4 * this.waterRipple;
        
        ctx.fillStyle = `rgba(200, 230, 250, ${dotAlpha})`;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
  }
  
  // ç»˜åˆ¶ç˜¦é©¬
  private drawHorse(ctx: CanvasRenderingContext2D, x: number, y: number): void {
    ctx.fillStyle = 'rgba(80, 60, 40, 0.8)';
    
    // é©¬èº«
    ctx.fillRect(x - 20, y - 15, 40, 20);
    
    // é©¬å¤´
    ctx.beginPath();
    ctx.arc(x + 20, y - 20, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // é©¬è…¿
    ctx.fillRect(x - 15, y + 5, 4, 15);
    ctx.fillRect(x - 5, y + 5, 4, 15);
    ctx.fillRect(x + 5, y + 5, 4, 15);
    ctx.fillRect(x + 15, y + 5, 4, 15);
    
    // é©¬å°¾ (å¦‚æœåœä¸‹åˆ™æ‰«å‡ºå¤©æ¶¯)
    if (this.horseStop) {
      ctx.strokeStyle = 'rgba(100, 80, 60, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 20, y - 5);
      ctx.quadraticCurveTo(x - 40, y - 10, x - 50, y + 5);
      ctx.stroke();
    }
  }
  
  // ç»˜åˆ¶æš—è§’
  private drawVignette(ctx: CanvasRenderingContext2D): void {
    const gradient = ctx.createRadialGradient(
      this.canvasWidth / 2, this.canvasHeight / 2, this.canvasHeight * 0.3,
      this.canvasWidth / 2, this.canvasHeight / 2, this.canvasHeight * 0.8
    );
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(1, `rgba(0, 0, 0, ${this.vignetteAlpha})`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
  }
  
  // ç»˜åˆ¶"å¤©æ¶¯"æ–‡å­—
  private drawTianyaText(ctx: CanvasRenderingContext2D): void {
    ctx.save();
    ctx.font = 'bold 50px serif';
    ctx.fillStyle = `rgba(150, 120, 80, ${1.0 - (Date.now() % 3000) / 3000})`; // æ¸éšæ•ˆæœ
    ctx.textAlign = 'center';
    ctx.fillText('å¤©æ¶¯', this.canvasWidth * 0.75, this.canvasHeight * 0.5);
    ctx.restore();
  }
  
  // ç»˜åˆ¶"æ–­è‚ äººåœ¨å¤©æ¶¯"æ®‹å½±
  private drawDuanchangText(ctx: CanvasRenderingContext2D): void {
    ctx.save();
    ctx.font = 'bold 40px serif';
    ctx.fillStyle = 'rgba(200, 150, 100, 0.5)';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(255, 100, 50, 0.6)';
    ctx.shadowBlur = 15;
    ctx.fillText('æ–­è‚ äººåœ¨å¤©æ¶¯', this.canvasWidth * 0.5, this.canvasHeight * 0.4);
    ctx.restore();
  }

  // ç»˜åˆ¶æ°´è²ƒæ­Œå¤´åœºæ™¯ (ä¸­ç§‹å¤œ)
  private drawMoonPalace(ctx: CanvasRenderingContext2D): void {
    // 1. ç»˜åˆ¶æµ·é¢ (ä¸‹åŠéƒ¨åˆ†)
    const seaY = this.canvasHeight * 0.65;
    const seaGradient = ctx.createLinearGradient(0, seaY, 0, this.canvasHeight);
    seaGradient.addColorStop(0, 'rgba(20, 40, 80, 0.6)'); // æ·±è“æµ·é¢
    seaGradient.addColorStop(1, 'rgba(10, 20, 50, 0.8)'); // æ›´æ·±çš„æµ·æ°´
    ctx.fillStyle = seaGradient;
    ctx.fillRect(0, seaY, this.canvasWidth, this.canvasHeight - seaY);
    
    // 2. ç»˜åˆ¶æµ·é¢æ³¢çº¹ (æ‰©æ•£åœ†)
    this.seaWavePhase += 0.01;
    for (let i = 0; i < 5; i++) {
      const x = this.canvasWidth * (0.2 + i * 0.15);
      const y = seaY + 20 + Math.sin(this.seaWavePhase + i) * 10;
      const size = 30 + Math.sin(this.seaWavePhase * 2 + i) * 15;
      ctx.strokeStyle = `rgba(100, 150, 200, 0.2)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // 3. ç»˜åˆ¶æœˆå®«è™šå½± (åŠé€æ˜)
    if (this.palaceAlpha > 0) {
      const moonX = this.moonX * this.canvasWidth;
      const moonY = this.moonY * this.canvasHeight;
      ctx.save();
      ctx.globalAlpha = this.palaceAlpha;
      ctx.strokeStyle = 'rgba(200, 200, 220, 0.6)';
      ctx.lineWidth = 2;
      
      // ç»˜åˆ¶ç®€å•çš„å®«æ®¿è½®å»“
      const palaceW = 80;
      const palaceH = 50;
      ctx.strokeRect(moonX - palaceW/2, moonY - 30, palaceW, palaceH);
      // å±‹é¡¶
      ctx.beginPath();
      ctx.moveTo(moonX - palaceW/2 - 10, moonY - 30);
      ctx.lineTo(moonX, moonY - 50);
      ctx.lineTo(moonX + palaceW/2 + 10, moonY - 30);
      ctx.stroke();
      
      ctx.restore();
    }
    
    // 4. ç»˜åˆ¶å«¦å¨¥å‰ªå½± (æ‰è¿‡)
    if (this.changEAlpha > 0) {
      ctx.save();
      ctx.globalAlpha = this.changEAlpha;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      const eX = this.canvasWidth * 0.6;
      const eY = this.canvasHeight * 0.3;
      // ç®€å•çš„äººå½¢å‰ªå½±
      ctx.beginPath();
      ctx.arc(eX, eY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(eX - 10, eY + 8, 20, 30);
      ctx.restore();
    }
    
    // 5. ç»˜åˆ¶è‹è½¼ä¸¾æ¯
    if (this.suShiAlpha > 0) {
      const sX = this.canvasWidth * 0.2;
      const sY = this.canvasHeight * 0.5;
      
      ctx.save();
      ctx.globalAlpha = this.suShiAlpha;
      ctx.fillStyle = 'rgba(50, 50, 70, 0.9)';
      
      // å¤´éƒ¨
      ctx.beginPath();
      ctx.arc(sX, sY, 15, 0, Math.PI * 2);
      ctx.fill();
      
      // èº«ä½“
      ctx.fillRect(sX - 20, sY + 15, 40, 60);
      
      // ä¸¾èµ·çš„æ‰‹è‡‚ (æ‹¿æ¯)
      ctx.beginPath();
      ctx.moveTo(sX + 20, sY + 20);
      ctx.lineTo(sX + 40, sY - 10);
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'rgba(50, 50, 70, 0.9)';
      ctx.stroke();
      
      ctx.restore();
      
      // ç»˜åˆ¶é…’æ¯
      if (this.cupAlpha > 0) {
        ctx.save();
        ctx.globalAlpha = this.cupAlpha;
        ctx.fillStyle = 'rgba(180, 150, 100, 0.8)'; // é‡‘è‰²æ¯å­
        ctx.fillRect(sX + 35, sY - 15, 12, 18);
        // æ¯ä¸­é…’æ°´ (åå°„æ˜Ÿç©º)
        ctx.fillStyle = 'rgba(100, 100, 150, 0.6)';
        ctx.fillRect(sX + 37, sY - 13, 8, 10);
        ctx.restore();
      }
    }
    
    // 6. ç»˜åˆ¶å¤šé‡å½± (èµ·èˆå¼„æ¸…å½±)
    if (this.shadowCount === 3) {
      const centerX = this.canvasWidth * 0.5;
      const centerY = this.canvasHeight * 0.5;
      
      for (let i = 0; i < 3; i++) {
        const angle = (this.shadowRotation + i * 120) * Math.PI / 180;
        const offsetX = Math.cos(angle) * 50;
        const offsetY = Math.sin(angle) * 30;
        
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = 'rgba(100, 100, 150, 0.5)';
        const x = centerX + offsetX;
        const y = centerY + offsetY;
        
        // ç®€åŒ–çš„äººå½¢
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(x - 15, y + 12, 30, 40);
        ctx.restore();
      }
    }
    
    // 7. ç»˜åˆ¶æ—¶é—´éš§é“å€’è®¡æ—¶
    if (this.timeCountdown > 0) {
      const moonX = this.moonX * this.canvasWidth;
      const moonY = this.moonY * this.canvasHeight;
      
      ctx.save();
      ctx.font = 'bold 60px sans-serif';
      ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(this.timeCountdown.toString(), moonX, moonY);
      ctx.restore();
    }
    
    // 8. ç»˜åˆ¶å­”æ˜ç¯
    this.drawLanterns(ctx);
    
    // 9. ç»˜åˆ¶çƒŸèŠ±æ–‡å­— (ä½†æ„¿äººé•¿ä¹…)
    if (this.lanternBurst) {
      const centerX: number = this.canvasWidth * 0.5;
      const centerY: number = this.canvasHeight * 0.3 - 20; // å¾€ä¸Šç§»20åƒç´ 
      const spacing: number = 80;
      
      ctx.save();
      ctx.font = 'bold 80px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // çº¢è‰²å‘å…‰æ•ˆæœ
      ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillStyle = 'rgba(255, 50, 50, 1.0)'; // çº¢è‰²
      
      // ç»˜åˆ¶"é•¿"å­—
      ctx.fillText('é•¿', centerX - spacing, centerY);
      // ç»˜åˆ¶"ä¹…"å­—
      ctx.fillText('ä¹…', centerX + spacing, centerY);
      
      ctx.restore();
    }
  }
  
  // ç»˜åˆ¶å­”æ˜ç¯
  private drawLanterns(ctx: CanvasRenderingContext2D): void {
    this.lanterns.forEach(lantern => {
      ctx.save();
      ctx.globalAlpha = lantern.alpha;
      
      // ç¯ç¬¼æœ¬ä½“
      const gradient = ctx.createRadialGradient(
        lantern.x, lantern.y, 0,
        lantern.x, lantern.y, lantern.size
      );
      gradient.addColorStop(0, lantern.color);
      gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(lantern.x, lantern.y, lantern.size, 0, Math.PI * 2);
      ctx.fill();
      
      // çˆ†ç‚¸æ•ˆæœ
      if (lantern.isExploding) {
        ctx.strokeStyle = `rgba(255, 150, 50, ${1 - lantern.explodeProgress})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(lantern.x, lantern.y, lantern.size * (1 + lantern.explodeProgress * 2), 0, Math.PI * 2);
        ctx.stroke();
      }
      
      ctx.restore();
    });
  }

  // ç»˜åˆ¶ç²’å­
  private drawParticles(ctx: CanvasRenderingContext2D): void {
    this.particles.forEach((p: Particle) => {
      ctx.save();
      ctx.globalAlpha = p.alpha * p.life * this.particleOpacity;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  // åŠ¨ç”»å¾ªç¯
  private startAnimation(): void {
    const animate = (): void => {
      if (this.animationId === -1) {
        return; // å·²åœæ­¢åŠ¨ç”»
      }
      
      // æ›´æ–°ç²’å­
      this.updateParticles();
      
      // é™å¤œæ€ç‰¹æ®ŠåŠ¨ç”»
      const poem = this.livePoems[this.currentPoemIndex];
      if (poem.scene === 'night_moon') {
        // å‘¼å¸æ•ˆæœ (30% - 70% - 30%)
        this.breathePhase += 0.02;
        this.moonBrightness = 0.3 + Math.sin(this.breathePhase) * 0.2 + 0.2;
        
        // å­¤é›é£è¡Œ (å¶å°”å‡ºç°)
        if (!this.showGoose && Math.random() < 0.001) {
          this.showGoose = true;
          this.gooseX = -50;
          this.gooseY = this.canvasHeight * (0.2 + Math.random() * 0.2);
        }
        
        if (this.showGoose) {
          this.gooseX += 3;
          this.gooseY += Math.sin(this.gooseX * 0.05) * 0.5;
          if (this.gooseX > this.canvasWidth + 50) {
            this.showGoose = false;
          }
        }
      } else if (poem.scene === 'river_moon') {
        // æ˜¥æ±ŸèŠ±æœˆå¤œç‰¹æ®ŠåŠ¨ç”»
        // æ½®æ±å¼•åŠ›åŠ¨ç”» (20ç§’å‘¨æœŸ)
        this.tidePhase += 0.005 * this.timeAcceleration; // å¯åŠ é€Ÿ
        if (this.tidePhase > Math.PI * 2) {
          this.tidePhase = 0;
        }
        // æ½®æ°´é«˜åº¦: 0 -> 1 -> 0 (æ­£å¼¦æ³¢)
        this.tideHeight = (Math.sin(this.tidePhase) + 1) * 0.5;
      } else if (poem.scene === 'moon_palace') {
        // æ°´è°ƒæ­Œå¤´ - æ›´æ–°å­”æ˜ç¯
        this.updateLanterns();
      }
      
      // ç»˜åˆ¶åœºæ™¯
      this.drawScene();
      
      // ä½¿ç”¨setTimeoutæ¨¡æ‹Ÿr requestAnimationFrame (HarmonyOS)
      setTimeout(() => {
        animate();
      }, 16); // çº¦60fps
    };
    this.animationId = 1; // è®¾ç½®ä¸ºé-1è¡¨ç¤ºåŠ¨ç”»è¿è¡Œä¸­
    animate();
  }

  // è§¦æ‘¸æ‰‹åŠ¿å¤„ç†
  private onTouchMove(event: TouchEvent): void {
    const poem = this.livePoems[this.currentPoemIndex];
    
    console.log('Touch event type:', event.type, 'scene:', poem.scene);
    
    if (event.touches.length > 0 && this.canvasWidth > 0) {
      const touch = event.touches[0];
      
      // é™å¤œæ€ - ä¸å¤„ç†è§¦æ‘¸ï¼Œç”±æœ—è¯µæ‰“ç‚¹æ§åˆ¶
      if (poem.scene === 'night_moon') {
        console.log('night_moon - no manual interaction, controlled by recitation');
      } else if (poem.scene === 'river_moon') {
        // æ˜¥æ±ŸèŠ±æœˆå¤œ - ä¸å¤„ç†è§¦æ‘¸ï¼Œæœˆäº®ç”±åŠ¨ç”»æ§åˆ¶
        console.log('river_moon - no manual interaction');
      } else if (poem.scene === 'moon_palace') {
        // æ°´è°ƒæ­Œå¤´ - ç‚¹å‡»æ·»åŠ å­”æ˜ç¯
        if (event.type === TouchType.Down) {
          this.addLantern(touch.x, touch.y);
          console.log('ğŸ® æ·»åŠ å­”æ˜ç¯ at:', touch.x, touch.y);
        }
      } else {
        // å…¶ä»–åœºæ™¯ - æ™®é€šæ‹–åŠ¨æœˆäº®
        if (event.type === TouchType.Move || event.type === TouchType.Down) {
          this.moonX = touch.x / this.canvasWidth;
          this.moonY = touch.y / this.canvasHeight;
          
          // é™åˆ¶èŒƒå›´
          this.moonX = Math.max(0.1, Math.min(0.9, this.moonX));
          this.moonY = Math.max(0.1, Math.min(0.6, this.moonY));
        }
      }
    }
  }

  // åˆ‡æ¢è¯—è¯
  private switchPoem(delta: number): void {
    const newIndex = this.currentPoemIndex + delta;
    if (newIndex >= 0 && newIndex < this.livePoems.length) {
      this.currentPoemIndex = newIndex;
      this.isPlaying = false;
      
      // é‡ç½®é™å¤œæ€çŠ¶æ€
      this.moonScale = 1.0;
      this.libaiAlpha = 0;
      this.highlightFrost = false;
      this.moonBrightness = 0.5;
      
      // é‡ç½®æ˜¥æ±ŸèŠ±æœˆå¤œçŠ¶æ€
      this.moonAngle = 0;
      this.tideHeight = 0;
      this.moonPhase = 0;
      this.lightPathAlpha = 0;
      this.boatAlpha = 0;
      this.mapVisible = false;
      this.tidePhase = 0;
      this.timeAcceleration = 1.0;
      
      // é‡ç½®æœˆäº®ä½ç½®
      this.moonX = 0.7;
      this.moonY = 0.3;
      
      // é‡æ–°åˆå§‹åŒ–ç²’å­
      this.initParticles();
      
      // åœæ­¢å½“å‰æœ—è¯µ
      if (this.isInit) {
        TextReader.stop();
      }
    }
  }
  
  // è·å–è¯—å¥æ ·å¼ (ç”¨äºbuildæ–¹æ³•)
  private getLineStyle(line: string): LineStyle {
    const isNightMoon = this.livePoems[this.currentPoemIndex].scene === 'night_moon';
    const isFrostLine = line.includes('ç–‘æ˜¯åœ°ä¸Šéœœ');
    const shouldHighlight = isNightMoon && this.highlightFrost && isFrostLine;
    const shouldDim = isNightMoon && this.highlightFrost && !isFrostLine;
    
    const result: LineStyle = {
      fontSize: shouldHighlight ? 22 : 18,
      fontColor: shouldHighlight ? '#FFD700' : $r('app.color.text_primary'),
      fontWeight: shouldHighlight ? FontWeight.Bold : FontWeight.Normal,
      opacity: shouldDim ? 0.2 : 1.0
    };
    
    return result;
  }

  build() {
    Scroll() {
      Column() {
        // Canvasç”»å¸ƒå±‚ - å›ºå®šé«˜åº¦
        Column() {
          Canvas(this.context)
            .width('100%')
            .height('100%')
            .backgroundColor('#1a1a2e')
            .onReady(() => {
              console.log('Canvas onReady called');
              // ç›´æ¥ä½¿ç”¨contextçš„å®½é«˜
              this.canvasWidth = this.context.width;
              this.canvasHeight = this.context.height;
              
              console.log('Canvas size:', this.canvasWidth, 'x', this.canvasHeight);
              
              // å¦‚æœå°ºå¯¸ä¸º0ï¼Œä½¿ç”¨é»˜è®¤å€¼
              if (this.canvasWidth === 0 || this.canvasHeight === 0) {
                // è·å–å±å¹•å°ºå¯¸ä½œä¸ºé»˜è®¤å€¼
                this.canvasWidth = 360; // é»˜è®¤å®½åº¦
                this.canvasHeight = 500; // é»˜è®¤é«˜åº¦
                console.log('Using default size:', this.canvasWidth, 'x', this.canvasHeight);
              }
              
              // åˆå§‹åŒ–ç²’å­
              this.initParticles();
              
              // ç«‹å³ç»˜åˆ¶ä¸€æ¬¡
              this.drawScene();
              
              // å¼€å§‹åŠ¨ç”»å¾ªç¯
              this.startAnimation();
            })
            .onTouch((event: TouchEvent) => {
              this.onTouchMove(event);
            })
        }
        .width('100%')
        .height(500)  // å›ºå®šé«˜åº¦500px
        
        // è¯—è¯å†…å®¹æ˜¾ç¤º
        Column() {
        // é¡¶éƒ¨è¿”å›å’Œæ ‡é¢˜
        Row() {
          Image($r('sys.symbol.chevron_left'))
            .width(24)
            .height(24)
            .fillColor($r('app.color.text_primary'))
            .onClick(() => {
              router.back();
            })
          
          Text('è¯—è¯')
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor($r('app.color.text_primary'))
            .layoutWeight(1)
            .textAlign(TextAlign.Center)
          
          Text('   ')
            .width(24)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 8 })
        
        Blank()
        
        // è¯—è¯å†…å®¹åŒºåŸŸ
        Column() {
          // è¯—è¯æ ‡é¢˜å’Œä½œè€…
          Text(this.livePoems[this.currentPoemIndex].title)
            .fontSize(24)
            .fontWeight(FontWeight.Bold)
            .fontColor($r('app.color.text_primary'))
            .margin({ bottom: 8 })
          
          Text(`ã€${this.livePoems[this.currentPoemIndex].type === 'tang' ? 'å”' : 
                 this.livePoems[this.currentPoemIndex].type === 'song' ? 'å®‹' : 'å…ƒ'}ã€‘${this.livePoems[this.currentPoemIndex].author}`)
            .fontSize(14)
            .fontColor($r('app.color.text_secondary'))
            .margin({ bottom: 20 })
          
          // è¯—è¯å†…å®¹
          Column() {
            ForEach(this.livePoems[this.currentPoemIndex].content.split('\n'), 
              (line: string, lineIndex: number) => {
                Text(line)
                  .fontSize(this.getLineStyle(line).fontSize)
                  .fontColor(this.getLineStyle(line).fontColor)
                  .fontWeight(this.getLineStyle(line).fontWeight)
                  .margin({ bottom: 12 })
                  .textAlign(TextAlign.Center)
                  .opacity(this.getLineStyle(line).opacity)
                  .animation({
                    duration: 300,
                    curve: Curve.EaseInOut
                  })
              })
          }
          .width('100%')
          
          // æ§åˆ¶æŒ‰é’®åŒºåŸŸ
          Row() {
            // ä¸Šä¸€é¦–
            Button('ä¸Šä¸€é¦–')
              .fontSize(14)
              .fontColor($r('app.color.text_primary'))
              .backgroundColor($r('app.color.card_background'))
              .width(80)
              .height(50)
              .borderRadius(25)
              .enabled(this.currentPoemIndex > 0)
              .opacity(this.currentPoemIndex > 0 ? 1 : 0.3)
              .onClick(() => {
                this.switchPoem(-1);
              })
            
            Blank()
              .width(20)
            
            // æ’­æ”¾/æš‚åœ
            Button(this.isPlaying ? 'æš‚åœ' : 'æ’­æ”¾')
              .fontSize(16)
              .fontWeight(FontWeight.Bold)
              .fontColor('#FFFFFF')
              .backgroundColor($r('app.color.accent_positive'))
              .width(100)
              .height(60)
              .borderRadius(30)
              .onClick(() => {
                this.togglePlay();
              })
            
            Blank()
              .width(20)
            
            // ä¸‹ä¸€é¦–
            Button('ä¸‹ä¸€é¦–')
              .fontSize(14)
              .fontColor($r('app.color.text_primary'))
              .backgroundColor($r('app.color.card_background'))
              .width(80)
              .height(50)
              .borderRadius(25)
              .enabled(this.currentPoemIndex < this.livePoems.length - 1)
              .opacity(this.currentPoemIndex < this.livePoems.length - 1 ? 1 : 0.3)
              .onClick(() => {
                this.switchPoem(1);
              })
          }
          .justifyContent(FlexAlign.Center)
          .padding({ top: 24 })
          
          // æç¤ºæ–‡å­—
          Text(this.livePoems[this.currentPoemIndex].scene === 'night_moon' ? 
            'ğŸŒ™ é™å¤œæ€ï¼šç‚¹å‡»æ’­æ”¾è§‚çœ‹æœ—è¯µåŠ¨ç”»  | æœˆå…‰çˆ†å‘ã€æç™½å‡ºç°' :
            this.livePoems[this.currentPoemIndex].scene === 'river_moon' ?
            'ğŸŒŠ æ˜¥æ±ŸèŠ±æœˆå¤œï¼šç‚¹å‡»æ’­æ”¾å¯åŠ¨åŠ¨ç”» | æ½®æ±å¼•åŠ›ã€æœˆå…‰è·¯å¾„' :
            'ğŸ‘† ç‚¹å‡»æ’­æ”¾å¯åŠ¨æœ—è¯µè§‚çœ‹ç²’å­ç”»å·')
            .fontSize(12)
            .fontColor($r('app.color.text_tertiary'))
            .fontStyle(FontStyle.Italic)
            .margin({ top: 16 })
            .opacity(0.8)
        }
        .width('100%')
        .padding(24)
        .backgroundColor($r('app.color.page_background'))
        .borderRadius({ topLeft: 24, topRight: 24 })
      }
      .width('100%')
    }
    .width('100%')
  }
  .scrollable(ScrollDirection.Vertical)
  .scrollBar(BarState.Auto)
  .edgeEffect(EdgeEffect.Spring)
  .width('100%')
  .height('100%')
  .backgroundColor($r('app.color.page_background'))
}
}
